// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.4 (swiftlang-1205.0.26.9 clang-1205.0.19.55)
// swift-module-flags: -target x86_64-apple-ios11.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name PGW
import Darwin
import Foundation
import Swift
import SystemConfiguration
import UIKit
import WebKit
public struct BlockModeOption : Swift.OptionSet {
  public let rawValue: Swift.Int
  public init(rawValue: Swift.Int)
  @usableFromInline
  internal static let none: PGW.BlockModeOption
  @usableFromInline
  internal static let initializationVectorRequired: PGW.BlockModeOption
  @usableFromInline
  internal static let paddingRequired: PGW.BlockModeOption
  @usableFromInline
  internal static let useEncryptToDecrypt: PGW.BlockModeOption
  public typealias ArrayLiteralElement = PGW.BlockModeOption
  public typealias Element = PGW.BlockModeOption
  public typealias RawValue = Swift.Int
}
extension String {
  public func decryptBase64ToString(cipher: PGW.Cipher) throws -> Swift.String
  public func decryptBase64(cipher: PGW.Cipher) throws -> Swift.Array<Swift.UInt8>
}
@_inheritsConvenienceInitializers @objc final public class UserAddress : PGW.BaseModel {
  @objc override dynamic public init()
  @objc deinit
}
public struct CFB : PGW.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: PGW.CFB.Error, b: PGW.CFB.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum SegmentSize : Swift.Int {
    case cfb8
    case cfb128
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public let options: PGW.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>, segmentSize: PGW.CFB.SegmentSize = .cfb128)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping PGW.CipherOperationOnBlock, encryptionOperation: @escaping PGW.CipherOperationOnBlock) throws -> PGW.CipherModeWorker
}
@objc public class SecurePaySDK : ObjectiveC.NSObject {
  @objc convenience public init(apiEnvironment: PGW.SecurePayAPIEnvironment)
  @objc public init(apiEnvironment: PGW.SecurePayAPIEnvironment, enableLog: Swift.Bool)
  @objc public func securePayToken(cardNo: Swift.String?, expiryMonth: Swift.Int, expiryYear: Swift.Int, securityCode: Swift.String?, pin: Swift.String?) -> Swift.String
  @objc public func maskedCardNo() -> Swift.String
  @objc override dynamic public init()
  @objc deinit
}
@objc public enum SecurePayAPIEnvironment : Swift.Int {
  case PRODUCTION, SANDBOX
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public struct CTR {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: PGW.CTR.Error, b: PGW.CTR.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: PGW.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>, counter: Swift.Int = 0)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping PGW.CipherOperationOnBlock, encryptionOperation: @escaping PGW.CipherOperationOnBlock) throws -> PGW.CipherModeWorker
}
@_inheritsConvenienceInitializers @objc public class BaseRequest : PGW.BaseModel {
  @objc public var clientId: Swift.String
  @objc public var locale: Swift.String
  @objc override dynamic public init()
  @objc deinit
}
@usableFromInline
final internal class StreamDecryptor : PGW.Cryptor, PGW.Updatable {
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal var worker: PGW.CipherModeWorker
  @usableFromInline
  final internal let padding: PGW.Padding
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var lastBlockRemainder: Swift.Int
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: PGW.Padding, _ worker: PGW.CipherModeWorker) throws
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    let toProcess = self.accumulated.prefix(max(self.accumulated.count - self.worker.additionalBufferSize, 0))

    if var finalizingWorker = worker as? FinalizingDecryptModeWorker, isLast == true {
      // will truncate suffix if needed
      try finalizingWorker.willDecryptLast(bytes: self.accumulated.slice)
    }

    var processedBytesCount = 0
    var plaintext = Array<UInt8>(reserveCapacity: bytes.count + self.worker.additionalBufferSize)
    for chunk in toProcess.batched(by: self.blockSize) {
      plaintext += self.worker.decrypt(block: chunk)
      processedBytesCount += chunk.count
    }

    if var finalizingWorker = worker as? FinalizingDecryptModeWorker, isLast == true {
      plaintext = Array(try finalizingWorker.didDecryptLast(bytes: plaintext.slice))
    }

    // omit unecessary calculation if not needed
    if self.padding != .noPadding {
      self.lastBlockRemainder = plaintext.count.quotientAndRemainder(dividingBy: self.blockSize).remainder
    }

    if isLast {
      // CTR doesn't need padding. Really. Add padding to the last block if really want. but... don't.
      plaintext = self.padding.remove(from: plaintext, blockSize: self.blockSize - self.lastBlockRemainder)
    }

    self.accumulated.removeFirst(processedBytesCount) // super-slow

    if var finalizingWorker = worker as? FinalizingDecryptModeWorker, isLast == true {
      plaintext = Array(try finalizingWorker.finalize(decrypt: plaintext.slice))
    }

    return plaintext
  }
  @inlinable final public func seek(to position: Swift.Int) throws {
    guard var worker = self.worker as? SeekableModeWorker else {
      fatalError("Not supported")
    }

    try worker.seek(to: position)
    self.worker = worker
  }
  @objc @usableFromInline
  deinit
}
extension ChaCha20 {
  convenience public init(key: Swift.String, iv: Swift.String) throws
}
@objc final public class PGWSDKParams : PGW.BaseModel {
  @objc final public var log: Swift.Bool
  @objc public init(apiEnvironment: PGW.APIEnvironment)
  @objc final public var apiEnvironment: PGW.APIEnvironment {
    @objc get
  }
  @objc final public var clientId: Swift.String! {
    @objc get
    @objc set(newValue)
  }
  @objc final public var locale: Swift.String! {
    @objc get
    @objc set(newValue)
  }
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc final public class MultipleCurrencyPricing : PGW.BaseExchangeRate {
  @objc override dynamic public init()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers final public class PaymentData : PGW.BaseModel {
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc final public class FXRate : PGW.BaseModel {
  @objc final public var sequenceNo: Swift.Int {
    get
  }
  @objc final public var id: Swift.String! {
    get
  }
  @objc final public var name: Swift.String! {
    get
  }
  @objc final public var iconUrl: Swift.String! {
    get
  }
  @objc final public var amount: Swift.String! {
    get
  }
  @objc final public var fx: Swift.Double {
    get
  }
  @objc final public var currencycode: Swift.String! {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
extension Collection where Self.Element == Swift.UInt8, Self.Index == Swift.Int {
  @inlinable internal func toUInt32Array() -> Swift.Array<Swift.UInt32> {
    guard !isEmpty else {
      return []
    }

    let c = strideCount(from: startIndex, to: endIndex, by: 4)
    return Array<UInt32>(unsafeUninitializedCapacity: c) { buf, count in
      var counter = 0
      for idx in stride(from: startIndex, to: endIndex, by: 4) {
        let val = UInt32(bytes: self, fromIndex: idx).bigEndian
        buf[counter] = val
        counter += 1
      }
      count = counter
      assert(counter == c)
    }
  }
  @inlinable internal func toUInt64Array() -> Swift.Array<Swift.UInt64> {
    guard !isEmpty else {
      return []
    }

    let c = strideCount(from: startIndex, to: endIndex, by: 8)
    return Array<UInt64>(unsafeUninitializedCapacity: c) { buf, count in
      var counter = 0
      for idx in stride(from: startIndex, to: endIndex, by: 8) {
        let val = UInt64(bytes: self, fromIndex: idx).bigEndian
        buf[counter] = val
        counter += 1
      }
      count = counter
      assert(counter == c)
    }
  }
}
@usableFromInline
internal func strideCount(from: Swift.Int, to: Swift.Int, by: Swift.Int) -> Swift.Int
@_inheritsConvenienceInitializers @objc final public class MerchantInfo : PGW.BaseMerchantInfo {
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc final public class SystemLocale : PGW.BaseModel {
  @objc final public var code: Swift.String! {
    get
  }
  @objc final public var name: Swift.String! {
    get
  }
  @objc final public var iconUrl: Swift.String! {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class BaseExchangeRate : PGW.BaseModel {
  @objc public var active: Swift.Bool {
    get
  }
  @objc public var terms: Swift.String! {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
extension Rabbit {
  convenience public init(key: Swift.String) throws
  convenience public init(key: Swift.String, iv: Swift.String) throws
}
extension Array {
  @inlinable internal init(reserveCapacity: Swift.Int) {
    self = Array<Element>()
    self.reserveCapacity(reserveCapacity)
  }
  @inlinable internal var slice: Swift.ArraySlice<Element> {
    get {
    self[self.startIndex ..< self.endIndex]
  }
  }
}
extension Array where Element == Swift.UInt8 {
  public init(hex: Swift.String)
  public func toHexString() -> Swift.String
}
extension Array where Element == Swift.UInt8 {
  @available(*, deprecated)
  public func chunks(size chunksize: Swift.Int) -> Swift.Array<Swift.Array<Element>>
  public func md5() -> [Element]
  public func sha1() -> [Element]
  public func sha224() -> [Element]
  public func sha256() -> [Element]
  public func sha384() -> [Element]
  public func sha512() -> [Element]
  public func sha2(_ variant: PGW.SHA2.Variant) -> [Element]
  public func sha3(_ variant: PGW.SHA3.Variant) -> [Element]
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public func crc16(seed: Swift.UInt16? = nil) -> Swift.UInt16
  public func encrypt(cipher: PGW.Cipher) throws -> [Element]
  public func decrypt(cipher: PGW.Cipher) throws -> [Element]
  public func authenticate<A>(with authenticator: A) throws -> [Element] where A : PGW.Authenticator
}
@_inheritsConvenienceInitializers @objc final public class DynamicCurrencyConversion : PGW.BaseExchangeRate {
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc final public class RecurringInfo : PGW.BaseModel {
  @objc final public var amount: Swift.String! {
    get
  }
  @objc final public var interval: Swift.Int {
    get
  }
  @objc final public var count: Swift.Int {
    get
  }
  @objc final public var chargeNextDate: Swift.String! {
    get
  }
  @objc final public var chargeOnDate: Swift.String! {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc final public class PaymentChannel : PGW.BaseModel {
  @objc final public var sequenceNo: Swift.Int {
    get
  }
  @objc final public var name: Swift.String! {
    get
  }
  @objc final public var currencyCodes: [Swift.String]! {
    get
  }
  @objc final public var iconUrl: Swift.String! {
    get
  }
  @objc final public var logoUrl: Swift.String! {
    get
  }
  @objc final public var down: Swift.Bool {
    get
  }
  @objc final public var context: PGW.PaymentContext! {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc final public class ExchangeRate : PGW.BaseModel {
  @objc final public var multipleCurrencyPricing: PGW.MultipleCurrencyPricing! {
    get
  }
  @objc final public var dynamicCurrencyConversion: PGW.DynamicCurrencyConversion! {
    get
  }
  @objc final public var alternativePaymentMethodMultipleCurrencyConversion: PGW.AlternativePaymentMethodMultipleCurrencyConversion! {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc final public class PaymentChannelGroup : PGW.BasePaymentChannel {
  @objc override dynamic public init()
  @objc deinit
}
public protocol CipherModeWorker {
  var cipherOperation: PGW.CipherOperationOnBlock { get }
  var additionalBufferSize: Swift.Int { get }
  @inlinable mutating func encrypt(block plaintext: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @inlinable mutating func decrypt(block ciphertext: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
}
public protocol BlockModeWorker : PGW.CipherModeWorker {
  var blockSize: Swift.Int { get }
}
public protocol CounterModeWorker : PGW.CipherModeWorker {
  associatedtype Counter
  var counter: Self.Counter { get set }
}
public protocol SeekableModeWorker : PGW.CipherModeWorker {
  mutating func seek(to position: Swift.Int) throws
}
public protocol StreamModeWorker : PGW.CipherModeWorker {
}
public protocol FinalizingEncryptModeWorker : PGW.CipherModeWorker {
  mutating func finalize(encrypt ciphertext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
}
public protocol FinalizingDecryptModeWorker : PGW.CipherModeWorker {
  @discardableResult
  mutating func willDecryptLast(bytes ciphertext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
  mutating func didDecryptLast(bytes plaintext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
  mutating func finalize(decrypt plaintext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
}
@_inheritsConvenienceInitializers @objc final public class CardTokenInfo : PGW.BaseModel {
  @objc final public var token: Swift.String! {
    get
  }
  @objc final public var cardNo: Swift.String! {
    get
  }
  @objc final public var expiryDate: Swift.String! {
    get
  }
  @objc final public var name: Swift.String! {
    get
  }
  @objc final public var email: Swift.String! {
    get
  }
  @objc final public var status: Swift.String! {
    get
  }
  @objc final public var iconUrl: Swift.String! {
    get
  }
  @objc final public var logoUrl: Swift.String! {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
public class CMAC : PGW.Authenticator {
  public enum Error : Swift.Error {
    case wrongKeyLength
    public static func == (a: PGW.CMAC.Error, b: PGW.CMAC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(key: Swift.Array<Swift.UInt8>) throws
  public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public func authenticate(_ bytes: Swift.Array<Swift.UInt8>, cipher: PGW.Cipher) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
public struct OFB : PGW.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: PGW.OFB.Error, b: PGW.OFB.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: PGW.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping PGW.CipherOperationOnBlock, encryptionOperation: @escaping PGW.CipherOperationOnBlock) throws -> PGW.CipherModeWorker
}
@_inheritsConvenienceInitializers @objc final public class SystemInitialization : PGW.BaseModel {
  @objc final public var locales: [PGW.SystemLocale]! {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class BaseModel : ObjectiveC.NSObject {
  public func print()
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc final public class PaymentNotification : PGW.BaseModel {
  @objc final public var facebook: Swift.Bool {
    get
  }
  @objc final public var whatsApp: Swift.Bool {
    get
  }
  @objc final public var line: Swift.Bool {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc final public class TransactionInfo : PGW.BaseTransactionInfo {
  @objc final public var recurring: PGW.RecurringInfo! {
    get
  }
  @objc final public var paymentItemInfos: [PGW.PaymentItemInfo]! {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class BasePaymentChannel : PGW.BaseModel {
  @objc public var sequenceNo: Swift.Int {
    get
  }
  @objc public var name: Swift.String! {
    get
  }
  @objc public var code: Swift.String! {
    get
  }
  @objc public var iconUrl: Swift.String! {
    get
  }
  @objc public var logoUrl: Swift.String! {
    get
  }
  @objc public var `default`: Swift.Bool {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
extension String {
  @inlinable public var bytes: Swift.Array<Swift.UInt8> {
    get {
    data(using: String.Encoding.utf8, allowLossyConversion: true)?.bytes ?? Array(utf8)
  }
  }
  @inlinable public func md5() -> Swift.String {
    self.bytes.md5().toHexString()
  }
  @inlinable public func sha1() -> Swift.String {
    self.bytes.sha1().toHexString()
  }
  @inlinable public func sha224() -> Swift.String {
    self.bytes.sha224().toHexString()
  }
  @inlinable public func sha256() -> Swift.String {
    self.bytes.sha256().toHexString()
  }
  @inlinable public func sha384() -> Swift.String {
    self.bytes.sha384().toHexString()
  }
  @inlinable public func sha512() -> Swift.String {
    self.bytes.sha512().toHexString()
  }
  @inlinable public func sha3(_ variant: PGW.SHA3.Variant) -> Swift.String {
    self.bytes.sha3(variant).toHexString()
  }
  @inlinable public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.String {
    self.bytes.crc32(seed: seed, reflect: reflect).bytes().toHexString()
  }
  @inlinable public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.String {
    self.bytes.crc32c(seed: seed, reflect: reflect).bytes().toHexString()
  }
  @inlinable public func crc16(seed: Swift.UInt16? = nil) -> Swift.String {
    self.bytes.crc16(seed: seed).bytes().toHexString()
  }
  @inlinable public func encrypt(cipher: PGW.Cipher) throws -> Swift.String {
    try self.bytes.encrypt(cipher: cipher).toHexString()
  }
  @inlinable public func encryptToBase64(cipher: PGW.Cipher) throws -> Swift.String {
    try self.bytes.encrypt(cipher: cipher).toBase64()
  }
  @inlinable public func authenticate<A>(with authenticator: A) throws -> Swift.String where A : PGW.Authenticator {
    try self.bytes.authenticate(with: authenticator).toHexString()
  }
}
@_inheritsConvenienceInitializers @objc final public class InstallmentPlan : PGW.BaseModel {
  @objc final public var sequenceNo: Swift.Int {
    get
  }
  @objc final public var period: Swift.Int {
    get
  }
  @objc final public var interestType: Swift.String! {
    get
  }
  @objc final public var interestRate: Swift.Double {
    get
  }
  @objc final public var monthlyAmount: Swift.Double {
    get
  }
  @objc final public var monthlyInterest: Swift.Double {
    get
  }
  @objc final public var currencyCode: Swift.String! {
    get
  }
  @objc final public var label: Swift.String! {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc final public class UserPreference : PGW.BaseModel {
  @objc final public var name: Swift.String! {
    get
  }
  @objc final public var email: Swift.String! {
    get
  }
  @objc final public var mobileNo: Swift.String! {
    get
  }
  @objc final public var mobileNoPrefix: Swift.String! {
    get
  }
  @objc final public var locale: Swift.String! {
    get
  }
  @objc final public var currencyCode: Swift.String! {
    get
  }
  @objc final public var countryCode: Swift.String! {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
public protocol _UInt8Type {
}
extension UInt8 : PGW._UInt8Type {
}
extension UInt8 {
  public func bits() -> [PGW.Bit]
  public func bits() -> Swift.String
}
@_inheritsConvenienceInitializers @objc final public class PaymentChannelCategory : PGW.BasePaymentChannel {
  @objc final public var groups: [PGW.PaymentChannelGroup]! {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
extension Array where Element == Swift.UInt8 {
  public func toBase64() -> Swift.String
  public init(base64: Swift.String)
}
@_inheritsConvenienceInitializers @objc final public class ConfigurationInfo : PGW.BaseModel {
  @objc final public var payment: PGW.PaymentConfiguration! {
    get
  }
  @objc final public var notification: PGW.PaymentNotification! {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
public struct ECB : PGW.BlockMode {
  public let options: PGW.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init()
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping PGW.CipherOperationOnBlock, encryptionOperation: @escaping PGW.CipherOperationOnBlock) throws -> PGW.CipherModeWorker
}
final public class OCB : PGW.BlockMode {
  public enum Mode {
    case combined
    case detached
    public static func == (a: PGW.OCB.Mode, b: PGW.OCB.Mode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let options: PGW.BlockModeOption
  public enum Error : Swift.Error {
    case invalidNonce
    case fail
    public static func == (a: PGW.OCB.Error, b: PGW.OCB.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let customBlockSize: Swift.Int?
  final public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(nonce N: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, tagLength: Swift.Int = 16, mode: PGW.OCB.Mode = .detached)
  @inlinable convenience public init(nonce N: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, mode: PGW.OCB.Mode = .detached) {
    self.init(nonce: N, additionalAuthenticatedData: additionalAuthenticatedData, tagLength: authenticationTag.count, mode: mode)
    self.authenticationTag = authenticationTag
  }
  final public func worker(blockSize: Swift.Int, cipherOperation: @escaping PGW.CipherOperationOnBlock, encryptionOperation: @escaping PGW.CipherOperationOnBlock) throws -> PGW.CipherModeWorker
  @objc deinit
}
@usableFromInline
final internal class BlockEncryptor : PGW.Cryptor, PGW.Updatable {
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: PGW.Padding, _ worker: PGW.CipherModeWorker) throws
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8>
  @usableFromInline
  final internal func seek(to: Swift.Int) throws
  @objc @usableFromInline
  deinit
}
@_inheritsConvenienceInitializers @objc final public class PaymentResultAdditionalInfo : PGW.BaseModel {
  @objc final public var responseCode: Swift.String! {
    get
  }
  @objc final public var responseDescription: Swift.String! {
    get
  }
  @objc final public var redirectImmediately: Swift.Bool {
    get
  }
  @objc final public var autoRedirect: Swift.Bool {
    get
  }
  @objc final public var autoRedirectTimer: Swift.Int {
    get
  }
  @objc final public var frontendReturnUrl: Swift.String! {
    get
  }
  @objc final public var frontendReturnData: Swift.String! {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
public protocol Cryptor {
  mutating func seek(to: Swift.Int) throws
}
@_inheritsConvenienceInitializers @objc final public class CardNoValidation : PGW.BaseModel {
  @objc final public var prefixes: [Swift.String]! {
    get
  }
  @objc final public var regex: Swift.String! {
    get
  }
  @objc final public var luhn: Swift.Bool {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc final public class CardTypeValidation : PGW.BaseModel {
  @objc final public var sequenceNo: Swift.Int {
    get
  }
  @objc final public var name: Swift.String! {
    get
  }
  @objc final public var prefixes: [Swift.String]! {
    get
  }
  @objc final public var regex: Swift.String! {
    get
  }
  @objc final public var iconUrl: Swift.String! {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc final public class CommonValidation : PGW.BaseModel {
  @objc final public var cardNo: PGW.CardNoValidation! {
    get
  }
  @objc final public var cardTypes: [PGW.CardTypeValidation]! {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
public protocol AEAD {
  static var kLen: Swift.Int { get }
  static var ivRange: Swift.Range<Swift.Int> { get }
}
@objc final public class PaymentCode : PGW.BaseModel {
  @objc final public var channelCode: Swift.String! {
    get
  }
  @objc final public var agentCode: Swift.String! {
    get
  }
  @objc final public var agentChannelCode: Swift.String! {
    get
  }
  @objc public init(channelCode: Swift.String)
  @objc(initWithChannelCode:agentCode:agentChannelCode:) public init(channelCode: Swift.String, _ agentCode: Swift.String, _ agentChannelCode: Swift.String)
  @objc override dynamic public init()
  @objc deinit
}
extension Blowfish {
  convenience public init(key: Swift.String, iv: Swift.String, padding: PGW.Padding = .pkcs7) throws
}
@_hasMissingDesignatedInitializers final public class AEADChaCha20Poly1305 : PGW.AEAD {
  public static let kLen: Swift.Int
  public static var ivRange: Swift.Range<Swift.Int>
  public static func encrypt(_ plainText: Swift.Array<Swift.UInt8>, key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>, authenticationHeader: Swift.Array<Swift.UInt8>) throws -> (cipherText: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>)
  public static func decrypt(_ cipherText: Swift.Array<Swift.UInt8>, key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>, authenticationHeader: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>) throws -> (plainText: Swift.Array<Swift.UInt8>, success: Swift.Bool)
  @objc deinit
}
@_inheritsConvenienceInitializers @objc final public class PaymentConfiguration : PGW.BaseModel {
  @objc final public var immediatePayment: Swift.Bool {
    get
  }
  @objc final public var tokenize: Swift.Bool {
    get
  }
  @objc final public var tokenizeOnly: Swift.Bool {
    get
  }
  @objc final public var cardTokenOnly: Swift.Bool {
    get
  }
  @objc final public var exchangeRate: PGW.ExchangeRate! {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc final public class PaymentContext : PGW.BaseModel {
  @objc final public var code: PGW.PaymentCode! {
    get
  }
  @objc final public var input: PGW.PaymentInput! {
    get
  }
  @objc final public var validation: PGW.PaymentValidation! {
    get
  }
  @objc final public var info: PGW.PaymentInfo! {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
final public class Blowfish {
  public enum Error : Swift.Error {
    case dataPaddingRequired
    case invalidKeyOrInitializationVector
    case invalidInitializationVector
    case invalidBlockMode
    public static func == (a: PGW.Blowfish.Error, b: PGW.Blowfish.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>, blockMode: PGW.BlockMode = CBC(iv: Array<UInt8>(repeating: 0, count: Blowfish.blockSize)), padding: PGW.Padding) throws
  @objc deinit
}
extension Blowfish : PGW.Cipher {
  final public func encrypt<C>(_ bytes: C) throws -> Swift.Array<Swift.UInt8> where C : Swift.Collection, C.Element == Swift.UInt8, C.Index == Swift.Int
  final public func decrypt<C>(_ bytes: C) throws -> Swift.Array<Swift.UInt8> where C : Swift.Collection, C.Element == Swift.UInt8, C.Index == Swift.Int
}
@_inheritsConvenienceInitializers @objc final public class PaymentInfo : PGW.BaseModel {
  @objc final public var terms: Swift.String! {
    get
  }
  @objc final public var promoUrl: Swift.String! {
    get
  }
  @objc final public var installmentPlans: [PGW.InstallmentPlan]! {
    get
  }
  @objc final public var paymentCustomDatas: [PGW.PaymentCustomData]! {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
final public class SHA1 {
  @usableFromInline
  internal static let digestLength: Swift.Int
  @usableFromInline
  internal static let blockSize: Swift.Int
  @usableFromInline
  internal static let hashInitialValue: Swift.ContiguousArray<Swift.UInt32>
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var processedBytesTotalCount: Swift.Int
  @usableFromInline
  final internal var accumulatedHash: Swift.ContiguousArray<Swift.UInt32>
  public init()
  @inlinable final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8> {
    do {
      return try update(withBytes: bytes.slice, isLast: true)
    } catch {
      return []
    }
  }
  @usableFromInline
  final internal func process(block chunk: Swift.ArraySlice<Swift.UInt8>, currentHash hh: inout Swift.ContiguousArray<Swift.UInt32>)
  @objc deinit
}
extension SHA1 : PGW.Updatable {
  @discardableResult
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    if isLast {
      let lengthInBits = (processedBytesTotalCount + self.accumulated.count) * 8
      let lengthBytes = lengthInBits.bytes(totalBytes: 64 / 8) // A 64-bit representation of b

      // Step 1. Append padding
      bitPadding(to: &self.accumulated, blockSize: SHA1.blockSize, allowance: 64 / 8)

      // Step 2. Append Length a 64-bit representation of lengthInBits
      self.accumulated += lengthBytes
    }

    var processedBytes = 0
    for chunk in self.accumulated.batched(by: SHA1.blockSize) {
      if isLast || (self.accumulated.count - processedBytes) >= SHA1.blockSize {
        self.process(block: chunk, currentHash: &self.accumulatedHash)
        processedBytes += chunk.count
      }
    }
    self.accumulated.removeFirst(processedBytes)
    self.processedBytesTotalCount += processedBytes

    // output current hash
    var result = Array<UInt8>(repeating: 0, count: SHA1.digestLength)
    var pos = 0
    for idx in 0..<self.accumulatedHash.count {
      let h = self.accumulatedHash[idx]
      result[pos + 0] = UInt8((h >> 24) & 0xff)
      result[pos + 1] = UInt8((h >> 16) & 0xff)
      result[pos + 2] = UInt8((h >> 8) & 0xff)
      result[pos + 3] = UInt8(h & 0xff)
      pos += 4
    }

    // reset hash value for instance
    if isLast {
      self.accumulatedHash = SHA1.hashInitialValue
    }

    return result
  }
}
@_inheritsConvenienceInitializers @objc final public class PaymentInput : PGW.BaseModel {
  @objc final public var name: Swift.String! {
    get
  }
  @objc final public var email: Swift.String! {
    get
  }
  @objc final public var mobileNo: Swift.String! {
    get
  }
  @objc final public var cardNo: Swift.String! {
    get
  }
  @objc final public var expiryDate: Swift.String! {
    get
  }
  @objc final public var securityCode: Swift.String! {
    get
  }
  @objc final public var pin: Swift.String! {
    get
  }
  @objc final public var token: Swift.String! {
    get
  }
  @objc final public var accountNo: Swift.String! {
    get
  }
  @objc final public var billingAddress1: Swift.String! {
    get
  }
  @objc final public var billingAddress2: Swift.String! {
    get
  }
  @objc final public var billingAddress3: Swift.String! {
    get
  }
  @objc final public var billingCity: Swift.String! {
    get
  }
  @objc final public var billingState: Swift.String! {
    get
  }
  @objc final public var billingPostalCode: Swift.String! {
    get
  }
  @objc final public var billingCountryCode: Swift.String! {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc final public class PaymentCustomData : PGW.BaseModel {
  @objc final public var sequenceNo: Swift.Int {
    get
  }
  @objc final public var type: Swift.String! {
    get
  }
  @objc final public var data: Swift.String! {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
public struct PCBC : PGW.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: PGW.PCBC.Error, b: PGW.PCBC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: PGW.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping PGW.CipherOperationOnBlock, encryptionOperation: @escaping PGW.CipherOperationOnBlock) throws -> PGW.CipherModeWorker
}
@_inheritsConvenienceInitializers @objc final public class PaymentRequest : PGW.BaseModel {
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc final public class PaymentValidation : PGW.BaseModel {
  @objc final public var name: Swift.String! {
    get
  }
  @objc final public var email: Swift.String! {
    get
  }
  @objc final public var mobileNo: Swift.String! {
    get
  }
  @objc final public var cardNo: Swift.String! {
    get
  }
  @objc final public var expiryDate: Swift.String! {
    get
  }
  @objc final public var securityCode: Swift.String! {
    get
  }
  @objc final public var pin: Swift.String! {
    get
  }
  @objc final public var token: Swift.String! {
    get
  }
  @objc final public var accountNo: Swift.String! {
    get
  }
  @objc final public var billingAddress1: Swift.String! {
    get
  }
  @objc final public var billingAddress2: Swift.String! {
    get
  }
  @objc final public var billingAddress3: Swift.String! {
    get
  }
  @objc final public var billingCity: Swift.String! {
    get
  }
  @objc final public var billingState: Swift.String! {
    get
  }
  @objc final public var billingPostalCode: Swift.String! {
    get
  }
  @objc final public var billingCountryCode: Swift.String! {
    get
  }
  @objc final public var additional: PGW.PaymentValidationAdditional! {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc final public class PaymentItemInfo : PGW.BaseModel {
  @objc final public var code: Swift.String! {
    get
  }
  @objc final public var name: Swift.String! {
    get
  }
  @objc final public var quantity: Swift.Int {
    get
  }
  @objc final public var price: Swift.Double {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
extension PKCS5 {
  public struct PBKDF1 {
    public enum Error : Swift.Error {
      case invalidInput
      case derivedKeyTooLong
      public static func == (a: PGW.PKCS5.PBKDF1.Error, b: PGW.PKCS5.PBKDF1.Error) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum Variant {
      case md5, sha1
      @usableFromInline
      internal var size: Swift.Int {
        get
      }
      @usableFromInline
      internal func calculateHash(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
      public static func == (a: PGW.PKCS5.PBKDF1.Variant, b: PGW.PKCS5.PBKDF1.Variant) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    @usableFromInline
    internal let iterations: Swift.Int
    @usableFromInline
    internal let variant: PGW.PKCS5.PBKDF1.Variant
    @usableFromInline
    internal let keyLength: Swift.Int
    @usableFromInline
    internal let t1: Swift.Array<Swift.UInt8>
    public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, variant: PGW.PKCS5.PBKDF1.Variant = .sha1, iterations: Swift.Int = 4096, keyLength: Swift.Int? = nil) throws
    @inlinable public func calculate() -> Swift.Array<Swift.UInt8> {
      var t = self.t1
      for _ in 2...self.iterations {
        t = self.variant.calculateHash(t)
      }
      return Array(t[0..<self.keyLength])
    }
  }
}
final public class GCM : PGW.BlockMode {
  public enum Mode {
    case combined
    case detached
    public static func == (a: PGW.GCM.Mode, b: PGW.GCM.Mode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let options: PGW.BlockModeOption
  public enum Error : Swift.Error {
    case invalidInitializationVector
    case fail
    public static func == (a: PGW.GCM.Error, b: PGW.GCM.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let customBlockSize: Swift.Int?
  final public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(iv: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, tagLength: Swift.Int = 16, mode: PGW.GCM.Mode = .detached)
  convenience public init(iv: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, mode: PGW.GCM.Mode = .detached)
  final public func worker(blockSize: Swift.Int, cipherOperation: @escaping PGW.CipherOperationOnBlock, encryptionOperation: @escaping PGW.CipherOperationOnBlock) throws -> PGW.CipherModeWorker
  @objc deinit
}
public protocol Updatable {
  mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8>
  mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool, output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws
}
extension Updatable {
  @inlinable public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false, output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    let processed = try update(withBytes: bytes, isLast: isLast)
    if !processed.isEmpty {
      output(processed)
    }
  }
  @inlinable public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: bytes, isLast: isLast)
  }
  @inlinable public mutating func update(withBytes bytes: Swift.Array<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: bytes.slice, isLast: isLast)
  }
  @inlinable public mutating func update(withBytes bytes: Swift.Array<Swift.UInt8>, isLast: Swift.Bool = false, output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    try self.update(withBytes: bytes.slice, isLast: isLast, output: output)
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: bytes, isLast: true)
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    try self.finish(withBytes: bytes.slice)
  }
  @inlinable public mutating func finish() throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: [], isLast: true)
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    let processed = try update(withBytes: bytes, isLast: true)
    if !processed.isEmpty {
      output(processed)
    }
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.Array<Swift.UInt8>, output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    try self.finish(withBytes: bytes.slice, output: output)
  }
  @inlinable public mutating func finish(output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    try self.finish(withBytes: [], output: output)
  }
}
public enum PKCS7 {
}
@_inheritsConvenienceInitializers @objc final public class PaymentValidationAdditional : PGW.BaseModel {
  @objc final public var cardNo: PGW.CardNoValidation! {
    get
  }
  @objc final public var amount: PGW.AmountValidation! {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc final public class TransactionStatusAdditionalInfo : PGW.BaseModel {
  @objc final public var merchantInfo: PGW.MerchantAdditionalInfo! {
    get
  }
  @objc final public var transactionInfo: PGW.TransactionAdditionalInfo! {
    get
  }
  @objc final public var resultInfo: PGW.PaymentResultAdditionalInfo! {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc final public class UserPreferenceInfo : PGW.BaseModel {
  @objc final public var preference: PGW.UserPreference! {
    get
  }
  @objc final public var channels: [PGW.UserPreferencePaymentChannel]! {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
final public class HMAC : PGW.Authenticator {
  public enum Error : Swift.Error {
    case authenticateError
    case invalidInput
    public static func == (a: PGW.HMAC.Error, b: PGW.HMAC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Variant {
    case sha1, sha256, sha384, sha512, md5
    public static func == (a: PGW.HMAC.Variant, b: PGW.HMAC.Variant) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(key: Swift.Array<Swift.UInt8>, variant: PGW.HMAC.Variant = .md5)
  final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
@_inheritsConvenienceInitializers @objc final public class UserPreferencePaymentChannel : PGW.BaseModel {
  @objc final public var sequenceNo: Swift.Int {
    get
  }
  @objc final public var name: Swift.String! {
    get
  }
  @objc final public var categoryCode: Swift.String! {
    get
  }
  @objc final public var groupCode: Swift.String! {
    get
  }
  @objc final public var channelCode: Swift.String! {
    get
  }
  @objc final public var iconUrl: Swift.String! {
    get
  }
  @objc final public var logoUrl: Swift.String! {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc final public class PaymentCustomDataCode : ObjectiveC.NSObject {
  @objc public static let Text: Swift.String
  @objc public static let ImageUrl: Swift.String
  @objc public static let WebUrl: Swift.String
  @objc public static let FileUrl: Swift.String
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc final public class UserPreferenceResponse : PGW.BaseResponse {
  @objc final public var paymentToken: Swift.String! {
    get
  }
  @objc final public var info: PGW.UserPreferenceInfo! {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
@objc final public class TransactionResultRequest : PGW.BaseRequest {
  @objc public init(paymentToken: Swift.String)
  @objc override dynamic public init()
  @objc deinit
}
public struct HKDF {
  public enum Error : Swift.Error {
    case invalidInput
    case derivedKeyTooLong
    public static func == (a: PGW.HKDF.Error, b: PGW.HKDF.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>? = nil, info: Swift.Array<Swift.UInt8>? = nil, keyLength: Swift.Int? = nil, variant: PGW.HMAC.Variant = .sha256) throws
  public func calculate() throws -> Swift.Array<Swift.UInt8>
}
@_inheritsConvenienceInitializers @objc final public class UserInfo : PGW.BaseModel {
  @objc final public var userAddress: PGW.UserAddress! {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc final public class ExchangeRateResponse : PGW.BaseResponse {
  @objc final public var paymentToken: Swift.String! {
    get
  }
  @objc final public var providerCode: Swift.String! {
    get
  }
  @objc final public var expire: Swift.Int {
    get
  }
  @objc final public var fxRates: [PGW.FXRate]! {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
final public class Poly1305 : PGW.Authenticator {
  public enum Error : Swift.Error {
    case authenticateError
    public static func == (a: PGW.Poly1305.Error, b: PGW.Poly1305.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>)
  final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
@_inheritsConvenienceInitializers @objc final public class TransactionStatusResponse : PGW.BaseResponse {
  @objc final public var channelCode: Swift.String! {
    get
  }
  @objc final public var invoiceNo: Swift.String! {
    get
  }
  @objc final public var additionalInfo: PGW.TransactionStatusAdditionalInfo! {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
extension UInt32 {
  @_specialize(exported: false, kind: full, where T == Swift.ArraySlice<Swift.UInt8>)
  @inlinable internal init<T>(bytes: T, fromIndex index: T.Index) where T : Swift.Collection, T.Element == Swift.UInt8, T.Index == Swift.Int {
    if bytes.isEmpty {
      self = 0
      return
    }

    let count = bytes.count

    let val0 = count > 0 ? UInt32(bytes[index.advanced(by: 0)]) << 24 : 0
    let val1 = count > 1 ? UInt32(bytes[index.advanced(by: 1)]) << 16 : 0
    let val2 = count > 2 ? UInt32(bytes[index.advanced(by: 2)]) << 8 : 0
    let val3 = count > 3 ? UInt32(bytes[index.advanced(by: 3)]) : 0

    self = val0 | val1 | val2 | val3
  }
}
@_inheritsConvenienceInitializers @objc final public class TransactionResultResponse : PGW.BaseTransactionResultResponse {
  @objc override dynamic public init()
  @objc deinit
}
public enum PKCS5 {
}
@_inheritsConvenienceInitializers @objc public class BaseResponse : PGW.BaseModel {
  @objc public var responseCode: Swift.String! {
    get
  }
  @objc public var responseDescription: Swift.String! {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc final public class BuyNowPayLaterPaymentBuilder : PGW.BasePaymentBuilder {
  @objc override public init(paymentCode: PGW.PaymentCode)
  @objc public init(channelCode: Swift.String)
  @objc final public func fxRateId(_ fxRateId: Swift.String) -> PGW.BuyNowPayLaterPaymentBuilder
  @objc final public func name(_ name: Swift.String) -> PGW.BuyNowPayLaterPaymentBuilder
  @objc final public func email(_ email: Swift.String) -> PGW.BuyNowPayLaterPaymentBuilder
  @objc final public func mobileNo(_ mobileNo: Swift.String) -> PGW.BuyNowPayLaterPaymentBuilder
  @objc final public func userAddress(_ userAddress: PGW.UserAddress) -> PGW.BuyNowPayLaterPaymentBuilder
  @objc final public func build() -> PGW.PaymentRequest
  @objc deinit
}
@inlinable internal func rotateLeft(_ value: Swift.UInt8, by: Swift.UInt8) -> Swift.UInt8 {
  ((value << by) & 0xff) | (value >> (8 - by))
}
@inlinable internal func rotateLeft(_ value: Swift.UInt16, by: Swift.UInt16) -> Swift.UInt16 {
  ((value << by) & 0xffff) | (value >> (16 - by))
}
@inlinable internal func rotateLeft(_ value: Swift.UInt32, by: Swift.UInt32) -> Swift.UInt32 {
  ((value << by) & 0xffffffff) | (value >> (32 - by))
}
@inlinable internal func rotateLeft(_ value: Swift.UInt64, by: Swift.UInt64) -> Swift.UInt64 {
  (value << by) | (value >> (64 - by))
}
@inlinable internal func rotateRight(_ value: Swift.UInt16, by: Swift.UInt16) -> Swift.UInt16 {
  (value >> by) | (value << (16 - by))
}
@inlinable internal func rotateRight(_ value: Swift.UInt32, by: Swift.UInt32) -> Swift.UInt32 {
  (value >> by) | (value << (32 - by))
}
@inlinable internal func rotateRight(_ value: Swift.UInt64, by: Swift.UInt64) -> Swift.UInt64 {
  ((value >> by) | (value << (64 - by)))
}
@inlinable internal func reversed(_ uint8: Swift.UInt8) -> Swift.UInt8 {
  var v = uint8
  v = (v & 0xf0) >> 4 | (v & 0x0f) << 4
  v = (v & 0xcc) >> 2 | (v & 0x33) << 2
  v = (v & 0xaa) >> 1 | (v & 0x55) << 1
  return v
}
@inlinable internal func reversed(_ uint32: Swift.UInt32) -> Swift.UInt32 {
  var v = uint32
  v = ((v >> 1) & 0x55555555) | ((v & 0x55555555) << 1)
  v = ((v >> 2) & 0x33333333) | ((v & 0x33333333) << 2)
  v = ((v >> 4) & 0x0f0f0f0f) | ((v & 0x0f0f0f0f) << 4)
  v = ((v >> 8) & 0x00ff00ff) | ((v & 0x00ff00ff) << 8)
  v = ((v >> 16) & 0xffff) | ((v & 0xffff) << 16)
  return v
}
@inlinable internal func xor<T, V>(_ left: T, _ right: V) -> Swift.ArraySlice<Swift.UInt8> where T : Swift.RandomAccessCollection, V : Swift.RandomAccessCollection, T.Element == Swift.UInt8, T.Index == Swift.Int, V.Element == Swift.UInt8, V.Index == Swift.Int {
  return xor(left, right).slice
}
@inlinable internal func xor<T, V>(_ left: T, _ right: V) -> Swift.Array<Swift.UInt8> where T : Swift.RandomAccessCollection, V : Swift.RandomAccessCollection, T.Element == Swift.UInt8, T.Index == Swift.Int, V.Element == Swift.UInt8, V.Index == Swift.Int {
  let length = Swift.min(left.count, right.count)

  let buf = UnsafeMutablePointer<UInt8>.allocate(capacity: length)
  buf.initialize(repeating: 0, count: length)
  defer {
    buf.deinitialize(count: length)
    buf.deallocate()
  }

  // xor
  for i in 0..<length {
    buf[i] = left[left.startIndex.advanced(by: i)] ^ right[right.startIndex.advanced(by: i)]
  }

  return Array(UnsafeBufferPointer(start: buf, count: length))
}
@inline(__always) @inlinable internal func bitPadding(to data: inout Swift.Array<Swift.UInt8>, blockSize: Swift.Int, allowance: Swift.Int = 0) {
  let msgLength = data.count
  // Step 1. Append Padding Bits
  // append one bit (UInt8 with one bit) to message
  data.append(0x80)

  // Step 2. append "0" bit until message length in bits  448 (mod 512)
  let max = blockSize - allowance // 448, 986
  if msgLength % blockSize < max { // 448
    data += Array<UInt8>(repeating: 0, count: max - 1 - (msgLength % blockSize))
  } else {
    data += Array<UInt8>(repeating: 0, count: blockSize + max - 1 - (msgLength % blockSize))
  }
}
@_inheritsConvenienceInitializers @objc final public class UserBillingAddress : PGW.BaseModel {
  @objc final public var address1: Swift.String!
  @objc final public var address2: Swift.String!
  @objc final public var address3: Swift.String!
  @objc final public var city: Swift.String!
  @objc final public var state: Swift.String!
  @objc final public var postalCode: Swift.String!
  @objc final public var countryCode: Swift.String!
  @objc override dynamic public init()
  @objc deinit
}
@objc final public class PaymentOptionDetailRequest : PGW.BaseRequest {
  @objc final public var categoryCode: Swift.String
  @objc final public var groupCode: Swift.String
  @objc public init(paymentToken: Swift.String)
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc final public class PaymentOptionResponse : PGW.BaseResponse {
  @objc final public var paymentToken: Swift.String! {
    get
  }
  @objc final public var merchantInfo: PGW.MerchantInfo! {
    get
  }
  @objc final public var userInfo: PGW.UserInfo! {
    get
  }
  @objc final public var channels: [PGW.PaymentChannelCategory]! {
    get
  }
  @objc final public var transactionInfo: PGW.TransactionInfo! {
    get
  }
  @objc final public var configurationInfo: PGW.ConfigurationInfo! {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
extension UInt64 {
  @_specialize(exported: false, kind: full, where T == Swift.ArraySlice<Swift.UInt8>)
  @inlinable internal init<T>(bytes: T, fromIndex index: T.Index) where T : Swift.Collection, T.Element == Swift.UInt8, T.Index == Swift.Int {
    if bytes.isEmpty {
      self = 0
      return
    }

    let count = bytes.count

    let val0 = count > 0 ? UInt64(bytes[index.advanced(by: 0)]) << 56 : 0
    let val1 = count > 1 ? UInt64(bytes[index.advanced(by: 1)]) << 48 : 0
    let val2 = count > 2 ? UInt64(bytes[index.advanced(by: 2)]) << 40 : 0
    let val3 = count > 3 ? UInt64(bytes[index.advanced(by: 3)]) << 32 : 0
    let val4 = count > 4 ? UInt64(bytes[index.advanced(by: 4)]) << 24 : 0
    let val5 = count > 5 ? UInt64(bytes[index.advanced(by: 5)]) << 16 : 0
    let val6 = count > 6 ? UInt64(bytes[index.advanced(by: 6)]) << 8 : 0
    let val7 = count > 7 ? UInt64(bytes[index.advanced(by: 7)]) : 0

    self = val0 | val1 | val2 | val3 | val4 | val5 | val6 | val7
  }
}
@objc final public class PaymentOptionRequest : PGW.BaseRequest {
  @objc public init(paymentToken: Swift.String)
  @objc override dynamic public init()
  @objc deinit
}
final public class SHA2 {
  @usableFromInline
  final internal let variant: PGW.SHA2.Variant
  @usableFromInline
  final internal let size: Swift.Int
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal let digestLength: Swift.Int
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var processedBytesTotalCount: Swift.Int
  @usableFromInline
  final internal var accumulatedHash32: [Swift.UInt32]
  @usableFromInline
  final internal var accumulatedHash64: [Swift.UInt64]
  public enum Variant : Swift.RawRepresentable {
    case sha224, sha256, sha384, sha512
    public var digestLength: Swift.Int {
      get
    }
    public var blockSize: Swift.Int {
      get
    }
    public typealias RawValue = Swift.Int
    public var rawValue: PGW.SHA2.Variant.RawValue {
      get
    }
    public init?(rawValue: PGW.SHA2.Variant.RawValue)
    @usableFromInline
    internal var h: Swift.Array<Swift.UInt64> {
      get
    }
    @usableFromInline
    internal var finalLength: Swift.Int {
      get
    }
  }
  public init(variant: PGW.SHA2.Variant)
  @inlinable final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8> {
    do {
      return try update(withBytes: bytes.slice, isLast: true)
    } catch {
      return []
    }
  }
  @usableFromInline
  final internal func process64(block chunk: Swift.ArraySlice<Swift.UInt8>, currentHash hh: inout Swift.Array<Swift.UInt64>)
  @usableFromInline
  final internal func process32(block chunk: Swift.ArraySlice<Swift.UInt8>, currentHash hh: inout Swift.Array<Swift.UInt32>)
  @objc deinit
}
extension SHA2 : PGW.Updatable {
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    if isLast {
      let lengthInBits = (processedBytesTotalCount + self.accumulated.count) * 8
      let lengthBytes = lengthInBits.bytes(totalBytes: self.blockSize / 8) // A 64-bit/128-bit representation of b. blockSize fit by accident.

      // Step 1. Append padding
      bitPadding(to: &self.accumulated, blockSize: self.blockSize, allowance: self.blockSize / 8)

      // Step 2. Append Length a 64-bit representation of lengthInBits
      self.accumulated += lengthBytes
    }

    var processedBytes = 0
    for chunk in self.accumulated.batched(by: self.blockSize) {
      if isLast || (self.accumulated.count - processedBytes) >= self.blockSize {
        switch self.variant {
          case .sha224, .sha256:
            self.process32(block: chunk, currentHash: &self.accumulatedHash32)
          case .sha384, .sha512:
            self.process64(block: chunk, currentHash: &self.accumulatedHash64)
          @unknown default:
            preconditionFailure()
          }
        processedBytes += chunk.count
      }
    }
    self.accumulated.removeFirst(processedBytes)
    self.processedBytesTotalCount += processedBytes

    // output current hash
    var result = Array<UInt8>(repeating: 0, count: variant.digestLength)
    switch self.variant {
      case .sha224, .sha256:
        var pos = 0
        for idx in 0..<self.accumulatedHash32.count where idx < self.variant.finalLength {
          let h = accumulatedHash32[idx]
          result[pos + 0] = UInt8((h >> 24) & 0xff)
          result[pos + 1] = UInt8((h >> 16) & 0xff)
          result[pos + 2] = UInt8((h >> 8) & 0xff)
          result[pos + 3] = UInt8(h & 0xff)
          pos += 4
        }
      case .sha384, .sha512:
        var pos = 0
        for idx in 0..<self.accumulatedHash64.count where idx < self.variant.finalLength {
          let h = accumulatedHash64[idx]
          result[pos + 0] = UInt8((h >> 56) & 0xff)
          result[pos + 1] = UInt8((h >> 48) & 0xff)
          result[pos + 2] = UInt8((h >> 40) & 0xff)
          result[pos + 3] = UInt8((h >> 32) & 0xff)
          result[pos + 4] = UInt8((h >> 24) & 0xff)
          result[pos + 5] = UInt8((h >> 16) & 0xff)
          result[pos + 6] = UInt8((h >> 8) & 0xff)
          result[pos + 7] = UInt8(h & 0xff)
          pos += 8
        }
      @unknown default:
          preconditionFailure()
    }

    // reset hash value for instance
    if isLast {
      switch self.variant {
        case .sha224, .sha256:
          self.accumulatedHash32 = self.variant.h.lazy.map { UInt32($0) } // FIXME: UInt64 for process64
        case .sha384, .sha512:
          self.accumulatedHash64 = self.variant.h
        @unknown default:
          preconditionFailure()
      }
    }

    return result
  }
}
@_inheritsConvenienceInitializers @objc final public class SystemInitializationResponse : PGW.BaseResponse {
  @objc final public var initialization: PGW.SystemInitialization! {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
extension PKCS5 {
  public struct PBKDF2 {
    public enum Error : Swift.Error {
      case invalidInput
      case derivedKeyTooLong
      public static func == (a: PGW.PKCS5.PBKDF2.Error, b: PGW.PKCS5.PBKDF2.Error) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, iterations: Swift.Int = 4096, keyLength: Swift.Int? = nil, variant: PGW.HMAC.Variant = .sha256) throws
    public func calculate() throws -> Swift.Array<Swift.UInt8>
  }
}
@objc final public class UserPreferenceRequest : PGW.BaseRequest {
  @objc public init(paymentToken: Swift.String)
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc final public class CardTokenInfoResponse : PGW.BaseResponse {
  @objc final public var paymentToken: Swift.String! {
    get
  }
  @objc final public var cardTokens: [PGW.CardTokenInfo]! {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc final public class UserAddressBuilder : PGW.BaseModel {
  @objc final public func userBillingAddress(_ userBillingAddress: PGW.UserBillingAddress) -> PGW.UserAddressBuilder
  @objc final public func build() -> PGW.UserAddress
  @objc override dynamic public init()
  @objc deinit
}
@objc final public class ExchangeRateRequest : PGW.BaseRequest {
  @objc final public var bin: Swift.String
  @objc public init(paymentToken: Swift.String)
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc final public class PaymentNotificationResponse : PGW.BaseResponse {
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc final public class PaymentOptionDetailResponse : PGW.BaseResponse {
  @objc final public var name: Swift.String! {
    get
  }
  @objc final public var categoryCode: Swift.String! {
    get
  }
  @objc final public var groupCode: Swift.String! {
    get
  }
  @objc final public var iconUrl: Swift.String! {
    get
  }
  @objc final public var validation: PGW.CommonValidation! {
    get
  }
  @objc final public var channels: [PGW.PaymentChannel]! {
    get
  }
  @objc final public var totalChannel: Swift.Int {
    get
  }
  @objc final public var configurationInfo: PGW.ConfigurationInfo! {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
@objc final public class PaymentNotificationRequest : PGW.BaseRequest {
  @objc final public var platform: Swift.String
  @objc final public var recipientId: Swift.String
  @objc final public var recipientName: Swift.String
  @objc public init(paymentToken: Swift.String)
  @objc override dynamic public init()
  @objc deinit
}
public typealias PGWWebViewTransactionStatusInquiry = (Swift.String) -> ()
public protocol PaddingProtocol {
  func add(to: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
  func remove(from: Swift.Array<Swift.UInt8>, blockSize: Swift.Int?) -> Swift.Array<Swift.UInt8>
}
public enum Padding : PGW.PaddingProtocol {
  case noPadding, zeroPadding, pkcs7, pkcs5, iso78164
  public func add(to: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
  public func remove(from: Swift.Array<Swift.UInt8>, blockSize: Swift.Int?) -> Swift.Array<Swift.UInt8>
  public static func == (a: PGW.Padding, b: PGW.Padding) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc final public class TransactionStatusRequest : PGW.BaseRequest {
  @objc final public var additionalInfo: Swift.Bool
  @objc public init(paymentToken: Swift.String)
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc final public class SystemInitializationRequest : PGW.BaseRequest {
  @objc override dynamic public init()
  @objc deinit
}
@objc final public class CardTokenInfoRequest : PGW.BaseRequest {
  @objc public init(paymentToken: Swift.String)
  @objc override dynamic public init()
  @objc deinit
}
@objc final public class CancelTransactionRequest : PGW.BaseRequest {
  @objc public init(paymentToken: Swift.String)
  @objc override dynamic public init()
  @objc deinit
}
extension Data {
  public func checksum() -> Swift.UInt16
  public func md5() -> Foundation.Data
  public func sha1() -> Foundation.Data
  public func sha224() -> Foundation.Data
  public func sha256() -> Foundation.Data
  public func sha384() -> Foundation.Data
  public func sha512() -> Foundation.Data
  public func sha3(_ variant: PGW.SHA3.Variant) -> Foundation.Data
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Foundation.Data
  public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Foundation.Data
  public func crc16(seed: Swift.UInt16? = nil) -> Foundation.Data
  public func encrypt(cipher: PGW.Cipher) throws -> Foundation.Data
  public func decrypt(cipher: PGW.Cipher) throws -> Foundation.Data
  public func authenticate(with authenticator: PGW.Authenticator) throws -> Foundation.Data
}
extension Data {
  public init(hex: Swift.String)
  public var bytes: Swift.Array<Swift.UInt8> {
    get
  }
  public func toHexString() -> Swift.String
}
@_inheritsConvenienceInitializers @objc public class BaseTransactionResultResponse : PGW.BaseResponse {
  @objc public var channelCode: Swift.String! {
    get
  }
  @objc public var invoiceNo: Swift.String! {
    get
  }
  @objc public var type: Swift.String! {
    get
  }
  @objc public var data: Swift.String! {
    get
  }
  @objc public var fallbackData: Swift.String! {
    get
  }
  @objc public var expiryTimer: Swift.Int {
    get
  }
  @objc public var expiryDescription: Swift.String! {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc final public class CancelTransactionResponse : PGW.BaseTransactionResultResponse {
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc final public class PaymentChannelCode : ObjectiveC.NSObject {
  @_inheritsConvenienceInitializers @objc(PaymentChannelCodeCategory) final public class Category : ObjectiveC.NSObject {
    @objc public static let GlobalCardPayment: Swift.String
    @objc public static let LocalCardPayment: Swift.String
    @objc public static let LocalCardInstallmentPaymentPlan: Swift.String
    @objc public static let DigitalPayment: Swift.String
    @objc public static let QRPayment: Swift.String
    @objc public static let WebPayment: Swift.String
    @objc public static let SelfServiceMachine: Swift.String
    @objc public static let PayAtCounter: Swift.String
    @objc public static let InternetBanking: Swift.String
    @objc public static let GlobalBuyNowPayLater: Swift.String
    @objc override dynamic public init()
    @objc deinit
  }
  @_inheritsConvenienceInitializers @objc(PaymentChannelCodeGroup) final public class Group : ObjectiveC.NSObject {
    @objc public static let CreditCard: Swift.String
    @objc public static let ProprietaryCard: Swift.String
    @objc public static let GlobalInstallmentPaymentPlan: Swift.String
    @objc public static let LocalInstallmentPaymentPlan: Swift.String
    @objc public static let GlobalThirdPartyPayment: Swift.String
    @objc public static let LocalThirdPartyPayment: Swift.String
    @objc public static let EWalletPayment: Swift.String
    @objc public static let MasterPass: Swift.String
    @objc public static let QRCodePayment: Swift.String
    @objc public static let CardSchemeQRPayment: Swift.String
    @objc public static let ThaiQRPayment: Swift.String
    @objc public static let SingaporeQRPayment: Swift.String
    @objc public static let WebPayment: Swift.String
    @objc public static let AutomatedTellerMachine: Swift.String
    @objc public static let Kiosk: Swift.String
    @objc public static let BankCounter: Swift.String
    @objc public static let OverTheCounter: Swift.String
    @objc public static let InternetBanking: Swift.String
    @objc public static let BuyNowPayLater: Swift.String
    @objc override dynamic public init()
    @objc deinit
  }
  @objc override dynamic public init()
  @objc deinit
}
@objc public enum APIEnvironment : Swift.Int {
  case Production, ProductionIndonesia, Sandbox
  public func name() -> Swift.String
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension AES : PGW.Cryptors {
  @inlinable final public func makeEncryptor() throws -> PGW.Cryptor & PGW.Updatable {
    let blockSize = blockMode.customBlockSize ?? AES.blockSize
    let worker = try blockMode.worker(blockSize: blockSize, cipherOperation: encrypt, encryptionOperation: encrypt)
    if worker is StreamModeWorker {
      return try StreamEncryptor(blockSize: blockSize, padding: padding, worker)
    }
    return try BlockEncryptor(blockSize: blockSize, padding: padding, worker)
  }
  @inlinable final public func makeDecryptor() throws -> PGW.Cryptor & PGW.Updatable {
    let blockSize = blockMode.customBlockSize ?? AES.blockSize
    let cipherOperation: CipherOperationOnBlock = blockMode.options.contains(.useEncryptToDecrypt) == true ? encrypt : decrypt
    let worker = try blockMode.worker(blockSize: blockSize, cipherOperation: cipherOperation, encryptionOperation: encrypt)
    if worker is StreamModeWorker {
      return try StreamDecryptor(blockSize: blockSize, padding: padding, worker)
    }
    return try BlockDecryptor(blockSize: blockSize, padding: padding, worker)
  }
}
@_inheritsConvenienceInitializers @objc final public class PaymentInputCode : ObjectiveC.NSObject {
  @objc public static let Mandatory: Swift.String
  @objc public static let Ignore: Swift.String
  @objc public static let Optional: Swift.String
  @objc override dynamic public init()
  @objc deinit
}
final public class MD5 {
  public init()
  final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension MD5 : PGW.Updatable {
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
}
@_inheritsConvenienceInitializers @objc final public class APIResponseCode : ObjectiveC.NSObject {
  @objc public static let APISuccess: Swift.String
  @objc public static let TransactionAuthenticateRedirect: Swift.String
  @objc public static let TransactionAuthenticateFullRedirect: Swift.String
  @objc public static let TransactionExternalBrowser: Swift.String
  @objc public static let TransactionPaymentSlip: Swift.String
  @objc public static let TransactionExternalApplication: Swift.String
  @objc public static let TransactionQRPayment: Swift.String
  @objc public static let TransactionCompleted: Swift.String
  @objc public static let TransactionInProgress: Swift.String
  @objc public static let TransactionNotFound: Swift.String
  @objc public static let TransactionInquiryFailed: Swift.String
  @objc override dynamic public init()
  @objc deinit
}
public struct CBC : PGW.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: PGW.CBC.Error, b: PGW.CBC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: PGW.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping PGW.CipherOperationOnBlock, encryptionOperation: @escaping PGW.CipherOperationOnBlock) throws -> PGW.CipherModeWorker
}
@_inheritsConvenienceInitializers @objc final public class InstallmentInterestTypeCode : ObjectiveC.NSObject {
  @objc public static let Customer: Swift.String
  @objc public static let Merchant: Swift.String
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc final public class QRTypeCode : ObjectiveC.NSObject {
  @objc public static let Raw: Swift.String
  @objc public static let Base64: Swift.String
  @objc public static let URL: Swift.String
  @objc override dynamic public init()
  @objc deinit
}
final public class Rabbit {
  public enum Error : Swift.Error {
    case invalidKeyOrInitializationVector
    public static func == (a: PGW.Rabbit.Error, b: PGW.Rabbit.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let ivSize: Swift.Int
  public static let keySize: Swift.Int
  public static let blockSize: Swift.Int
  final public var keySize: Swift.Int {
    get
  }
  convenience public init(key: Swift.Array<Swift.UInt8>) throws
  public init(key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>?) throws
  @objc deinit
}
extension Rabbit : PGW.Cipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
@_inheritsConvenienceInitializers @objc final public class AlternativePaymentMethodMultipleCurrencyConversion : PGW.BaseExchangeRate {
  @objc override dynamic public init()
  @objc deinit
}
public protocol Cryptors : AnyObject {
  func makeEncryptor() throws -> PGW.Cryptor & PGW.Updatable
  func makeDecryptor() throws -> PGW.Cryptor & PGW.Updatable
  static func randomIV(_ blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
}
extension Cryptors {
  public static func randomIV(_ count: Swift.Int) -> Swift.Array<Swift.UInt8>
}
@_inheritsConvenienceInitializers @objc final public class PaymentNotificationPlatformCode : ObjectiveC.NSObject {
  @objc public static let Facebook: Swift.String
  @objc public static let WhatsApp: Swift.String
  @objc public static let WeChat: Swift.String
  @objc public static let Line: Swift.String
  @objc public static let Email: Swift.String
  @objc override dynamic public init()
  @objc deinit
}
extension HMAC {
  convenience public init(key: Swift.String, variant: PGW.HMAC.Variant = .md5) throws
}
extension AES {
  convenience public init(key: Swift.String, iv: Swift.String, padding: PGW.Padding = .pkcs7) throws
}
public typealias APIResponse<T> = (T) -> ()
public typealias APIFailure = (Foundation.NSError) -> ()
public typealias PGWWebViewNavigationDidStartProvisionalNavigation = (Swift.String) -> ()
public typealias PGWWebViewNavigationDecidePolicyForNavigationAction = (Swift.String) -> ()
public typealias PGWWebViewNavigationDidFinishNavigation = (Swift.String) -> ()
public class BlockDecryptor : PGW.Cryptor, PGW.Updatable {
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal let padding: PGW.Padding
  @usableFromInline
  internal var worker: PGW.CipherModeWorker
  @usableFromInline
  internal var accumulated: [Swift.UInt8]
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: PGW.Padding, _ worker: PGW.CipherModeWorker) throws
  @inlinable public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    // If a worker (eg GCM) can combine ciphertext + tag
    // we need to remove tag from the ciphertext.
    if !isLast && self.accumulated.count < self.blockSize + self.worker.additionalBufferSize {
      return []
    }

    let accumulatedWithoutSuffix: Array<UInt8>
    if self.worker.additionalBufferSize > 0 {
      // FIXME: how slow is that?
      accumulatedWithoutSuffix = Array(self.accumulated.prefix(self.accumulated.count - self.worker.additionalBufferSize))
    } else {
      accumulatedWithoutSuffix = self.accumulated
    }

    var processedBytesCount = 0
    var plaintext = Array<UInt8>(reserveCapacity: accumulatedWithoutSuffix.count)
    // Processing in a block-size manner. It's good for block modes, but bad for stream modes.
    for var chunk in accumulatedWithoutSuffix.batched(by: self.blockSize) {
      if isLast || (accumulatedWithoutSuffix.count - processedBytesCount) >= blockSize {
        let isLastChunk = processedBytesCount + chunk.count == accumulatedWithoutSuffix.count

        if isLast, isLastChunk, var finalizingWorker = worker as? FinalizingDecryptModeWorker {
          chunk = try finalizingWorker.willDecryptLast(bytes: chunk + accumulated.suffix(worker.additionalBufferSize)) // tag size
        }

        if !chunk.isEmpty {
          plaintext += worker.decrypt(block: chunk)
        }

        if isLast, isLastChunk, var finalizingWorker = worker as? FinalizingDecryptModeWorker {
          plaintext = Array(try finalizingWorker.didDecryptLast(bytes: plaintext.slice))
        }

        processedBytesCount += chunk.count
      }
    }
    accumulated.removeFirst(processedBytesCount) // super-slow

    if isLast {
      if accumulatedWithoutSuffix.isEmpty, var finalizingWorker = worker as? FinalizingDecryptModeWorker {
        try finalizingWorker.willDecryptLast(bytes: self.accumulated.suffix(self.worker.additionalBufferSize))
        plaintext = Array(try finalizingWorker.didDecryptLast(bytes: plaintext.slice))
      }
      plaintext = self.padding.remove(from: plaintext, blockSize: self.blockSize)
    }

    return plaintext
  }
  public func seek(to position: Swift.Int) throws
  @objc deinit
}
@_inheritsConvenienceInitializers @objc final public class Constants : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc deinit
}
extension Constants {
  @objc public static let JSON_NAME_PAYMENT_TOKEN: Swift.String
  @objc public static let JSON_NAME_NAME: Swift.String
  @objc public static let JSON_NAME_CODE: Swift.String
  @objc public static let JSON_NAME_ICON_URL: Swift.String
  @objc public static let JSON_NAME_AMOUNT: Swift.String
  @objc public static let JSON_NAME_CURRENCY_CODE: Swift.String
  @objc public static let JSON_NAME_DESCRIPTION: Swift.String
  @objc public static let JSON_NAME_MERCHANT_DETAILS: Swift.String
  @objc public static let JSON_NAME_PAYMENT_CHANNELS: Swift.String
  @objc public static let JSON_NAME_TRANSACTION_DETAILS: Swift.String
  @objc public static let JSON_NAME_ID: Swift.String
  @objc public static let JSON_NAME_ADDRESS: Swift.String
  @objc public static let JSON_NAME_EMAIL: Swift.String
  @objc public static let JSON_NAME_INSTALLMENT_PERIOD: Swift.String
  @objc public static let JSON_NAME_MOBILE_NO: Swift.String
  @objc public static let JSON_NAME_SECURITY_CODE: Swift.String
  @objc public static let JSON_NAME_CARD_TYPES: Swift.String
  @objc public static let JSON_NAME_RESP_CODE: Swift.String
  @objc public static let JSON_NAME_RESP_DESC: Swift.String
  @objc public static let JSON_NAME_TERMS: Swift.String
  @objc public static let JSON_NAME_LOGO_URL: Swift.String
  @objc public static let JSON_NAME_PROMO_URL: Swift.String
  @objc public static let JSON_NAME_PLANS: Swift.String
  @objc public static let JSON_NAME_INTEREST_TYPE: Swift.String
  @objc public static let JSON_NAME_INTEREST_RATE: Swift.String
  @objc public static let JSON_NAME_MONTHLY_AMOUNT: Swift.String
  @objc public static let JSON_NAME_MONTHLY_INTEREST: Swift.String
  @objc public static let JSON_NAME_LABEL: Swift.String
  @objc public static let JSON_NAME_PREFIXES: Swift.String
  @objc public static let JSON_NAME_CHANNELS: Swift.String
  @objc public static let JSON_NAME_TYPE: Swift.String
  @objc public static let JSON_NAME_AGENT_CODE: Swift.String
  @objc public static let JSON_NAME_AGENT_CHANNEL_CODE: Swift.String
  @objc public static let JSON_NAME_CHANNEL_CODE: Swift.String
  @objc public static let JSON_NAME_PERIOD: Swift.String
  @objc public static let JSON_NAME_SECURE_PAY_TOKEN: Swift.String
  @objc public static let JSON_NAME_INVOICE_NO: Swift.String
  @objc public static let JSON_NAME_CLIENT_ID: Swift.String
  @objc public static let JSON_NAME_LOCALE: Swift.String
  @objc public static let JSON_NAME_SEQUENCE_NO: Swift.String
  @objc public static let JSON_NAME_DEFAULT: Swift.String
  @objc public static let JSON_NAME_BANNER_URL: Swift.String
  @objc public static let JSON_NAME_INTERVAL: Swift.String
  @objc public static let JSON_NAME_COUNT: Swift.String
  @objc public static let JSON_NAME_CHARGE_NEXT_DATE: Swift.String
  @objc public static let JSON_NAME_CHARGE_ON_DATE: Swift.String
  @objc public static let JSON_NAME_RECURRING: Swift.String
  @objc public static let JSON_NAME_CHANNEL_CATEGORIES: Swift.String
  @objc public static let JSON_NAME_GROUPS: Swift.String
  @objc public static let JSON_NAME_PAYMENT: Swift.String
  @objc public static let JSON_NAME_FX: Swift.String
  @objc public static let JSON_NAME_MULTIPLE_CURRENCY_PRICING: Swift.String
  @objc public static let JSON_NAME_DYNAMIC_CURRENCY_CONVERSION: Swift.String
  @objc public static let JSON_NAME_ACTIVE: Swift.String
  @objc public static let JSON_NAME_CONFIGURATION: Swift.String
  @objc public static let JSON_NAME_CATEGORY_CODE: Swift.String
  @objc public static let JSON_NAME_GROUP_CODE: Swift.String
  @objc public static let JSON_NAME_TOKENIZE: Swift.String
  @objc public static let JSON_NAME_TOKENIZE_ONLY: Swift.String
  @objc public static let JSON_NAME_FACEBOOK: Swift.String
  @objc public static let JSON_NAME_WHATSAPP: Swift.String
  @objc public static let JSON_NAME_LINE: Swift.String
  @objc public static let JSON_NAME_NOTIFICATION: Swift.String
  @objc public static let JSON_NAME_EXPIRY_DATE: Swift.String
  @objc public static let JSON_NAME_PIN: Swift.String
  @objc public static let JSON_NAME_LUHN: Swift.String
  @objc public static let JSON_NAME_CARD_NO: Swift.String
  @objc public static let JSON_NAME_REGEX: Swift.String
  @objc public static let JSON_NAME_VALIDATION: Swift.String
  @objc public static let JSON_NAME_CURRENCY_CODES: Swift.String
  @objc public static let JSON_NAME_SERVICE_ID: Swift.String
  @objc public static let JSON_NAME_ITEM_TOTAL_PRICE: Swift.String
  @objc public static let JSON_NAME_SHIPPING_PRICE: Swift.String
  @objc public static let JSON_NAME_TAX: Swift.String
  @objc public static let JSON_NAME_TOTAL_PRICE: Swift.String
  @objc public static let JSON_NAME_BRANDS: Swift.String
  @objc public static let JSON_NAME_ACCOUNT_NO: Swift.String
  @objc public static let JSON_NAME_MASTERPASS: Swift.String
  @objc public static let JSON_NAME_CHECKOUT_ID: Swift.String
  @objc public static let JSON_NAME_CART_ID: Swift.String
  @objc public static let JSON_NAME_SUPPRESS_3DS: Swift.String
  @objc public static let JSON_NAME_SUPPRESS_CVC2: Swift.String
  @objc public static let JSON_NAME_NETWORKS: Swift.String
  @objc public static let JSON_NAME_BANK: Swift.String
  @objc public static let JSON_NAME_COUNTRY: Swift.String
  @objc public static let JSON_NAME_TOKEN: Swift.String
  @objc public static let JSON_NAME_DATA: Swift.String
  @objc public static let JSON_NAME_STATUS: Swift.String
  @objc public static let JSON_NAME_CARD_TOKENS: Swift.String
  @objc public static let JSON_NAME_BIN: Swift.String
  @objc public static let JSON_NAME_EXPIRE: Swift.String
  @objc public static let JSON_NAME_FX_RATES: Swift.String
  @objc public static let JSON_NAME_PREFERENCE: Swift.String
  @objc public static let JSON_NAME_USER: Swift.String
  @objc public static let JSON_NAME_INITIALIZATION: Swift.String
  @objc public static let JSON_NAME_PAYMENT_PLATFORM: Swift.String
  @objc public static let JSON_NAME_PAYMENT_RECIPIENT_ID: Swift.String
  @objc public static let JSON_NAME_PAYMENT_RECIPIENT_NAME: Swift.String
  @objc public static let JSON_NAME_ADDITIONAL_INFO: Swift.String
  @objc public static let JSON_NAME_PAYMENT_RESULT_DETAILS: Swift.String
  @objc public static let JSON_NAME_REDIRECT_IMMEDIATELY: Swift.String
  @objc public static let JSON_NAME_AUTO_REDIRECT: Swift.String
  @objc public static let JSON_NAME_AUTO_REDIRECT_TIMER: Swift.String
  @objc public static let JSON_NAME_FRONTEND_RETURN_URL: Swift.String
  @objc public static let JSON_NAME_FRONTEND_RETURN_DATA: Swift.String
  @objc public static let JSON_NAME_RESPONSE_RETURN_URL: Swift.String
  @objc public static let JSON_NAME_MOBILE_NO_PREFIX: Swift.String
  @objc public static let JSON_NAME_ADDITIONAL: Swift.String
  @objc public static let JSON_NAME_INPUT: Swift.String
  @objc public static let JSON_NAME_INFO: Swift.String
  @objc public static let JSON_NAME_TOTAL_CHANNEL: Swift.String
  @objc public static let JSON_NAME_CARD_TOKEN_ONLY: Swift.String
  @objc public static let JSON_NAME_CARD_BANK: Swift.String
  @objc public static let JSON_NAME_CARD_COUNTRY: Swift.String
  @objc public static let JSON_NAME_CARD_TOKENIZE: Swift.String
  @objc public static let JSON_NAME_INSTALLMENT_PLAN_PERIOD: Swift.String
  @objc public static let JSON_NAME_QR_TYPE: Swift.String
  @objc public static let JSON_NAME_FX_RATE_ID: Swift.String
  @objc public static let JSON_NAME_IS_DOWN: Swift.String
  @objc public static let JSON_NAME_IMMEDIATE_PAYMENT: Swift.String
  @objc public static let JSON_NAME_MIN: Swift.String
  @objc public static let JSON_NAME_MAX: Swift.String
  @objc public static let JSON_NAME_FALLBACK_DATA: Swift.String
  @objc public static let JSON_NAME_DATE_TIME: Swift.String
  @objc public static let JSON_NAME_PROVIDER_CODE: Swift.String
  @objc public static let JSON_NAME_COUNTRY_CODE: Swift.String
  @objc public static let JSON_NAME_QUANTITY: Swift.String
  @objc public static let JSON_NAME_PRICE: Swift.String
  @objc public static let JSON_NAME_PAYMENT_ITEMS: Swift.String
  @objc public static let JSON_NAME_USER_DETAILS: Swift.String
  @objc public static let JSON_NAME_USER_BILLING_ADDRESS: Swift.String
  @objc public static let JSON_NAME_ADDRESS_1: Swift.String
  @objc public static let JSON_NAME_ADDRESS_2: Swift.String
  @objc public static let JSON_NAME_ADDRESS_3: Swift.String
  @objc public static let JSON_NAME_CITY: Swift.String
  @objc public static let JSON_NAME_STATE: Swift.String
  @objc public static let JSON_NAME_POSTAL_CODE: Swift.String
  @objc public static let JSON_NAME_BILLING_ADDRESS_1: Swift.String
  @objc public static let JSON_NAME_BILLING_ADDRESS_2: Swift.String
  @objc public static let JSON_NAME_BILLING_ADDRESS_3: Swift.String
  @objc public static let JSON_NAME_BILLING_CITY: Swift.String
  @objc public static let JSON_NAME_BILLING_STATE: Swift.String
  @objc public static let JSON_NAME_BILLING_POSTAL_CODE: Swift.String
  @objc public static let JSON_NAME_BILLING_COUNTRY_CODE: Swift.String
  @objc public static let JSON_NAME_CUSTOM_DATA: Swift.String
  @objc public static let JSON_NAME_EXPIRY_TIMER: Swift.String
  @objc public static let JSON_NAME_EXPIRY_DESCRIPTION: Swift.String
  @objc public static let JSON_NAME_ALTERNATIVE_PAYMENT_METHOD_MULTIPLE_CURRENCY_CONVERSION: Swift.String
  @objc public static let JSON_NAME_MONTHLY_PAYMENT: Swift.String
}
@objc final public class PGWWebViewNavigationDelegate : PGW.BaseModel {
  @objc(initWithTransactionStatusCallback:) public init(_ transactionStatusCallback: @escaping PGW.PGWWebViewTransactionStatusInquiry)
  @objc(navigationCallbackWithDidStartProvisionalNavigation:decidePolicyForNavigationAction:didFinishNavigation:) final public func navigationCallback(didStartProvisionalNavigation: @escaping PGW.PGWWebViewNavigationDidStartProvisionalNavigation, decidePolicyForNavigationAction: @escaping PGW.PGWWebViewNavigationDecidePolicyForNavigationAction, didFinishNavigation: @escaping PGW.PGWWebViewNavigationDidFinishNavigation)
  @objc override dynamic public init()
  @objc deinit
}
extension PGWWebViewNavigationDelegate : WebKit.WKNavigationDelegate {
  @objc final public func webView(_ webView: WebKit.WKWebView, didStartProvisionalNavigation navigation: WebKit.WKNavigation!)
  @objc final public func webView(_ webView: WebKit.WKWebView, decidePolicyFor navigationAction: WebKit.WKNavigationAction, decisionHandler: @escaping (WebKit.WKNavigationActionPolicy) -> Swift.Void)
  @objc final public func webView(_ webView: WebKit.WKWebView, didFinish navigation: WebKit.WKNavigation!)
}
@_specialize(exported: false, kind: full, where T == Swift.Int)
@_specialize(exported: false, kind: full, where T == Swift.UInt)
@_specialize(exported: false, kind: full, where T == Swift.UInt8)
@_specialize(exported: false, kind: full, where T == Swift.UInt16)
@_specialize(exported: false, kind: full, where T == Swift.UInt32)
@_specialize(exported: false, kind: full, where T == Swift.UInt64)
@inlinable internal func arrayOfBytes<T>(value: T, length totalBytes: Swift.Int = MemoryLayout<T>.size) -> Swift.Array<Swift.UInt8> where T : Swift.FixedWidthInteger {
  let valuePointer = UnsafeMutablePointer<T>.allocate(capacity: 1)
  valuePointer.pointee = value

  let bytesPointer = UnsafeMutablePointer<UInt8>(OpaquePointer(valuePointer))
  var bytes = Array<UInt8>(repeating: 0, count: totalBytes)
  for j in 0..<min(MemoryLayout<T>.size, totalBytes) {
    bytes[totalBytes - 1 - j] = (bytesPointer + j).pointee
  }

  valuePointer.deinitialize(count: 1)
  valuePointer.deallocate()

  return bytes
}
public typealias CipherOperationOnBlock = (Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>?
public protocol BlockMode {
  var options: PGW.BlockModeOption { get }
  @inlinable func worker(blockSize: Swift.Int, cipherOperation: @escaping PGW.CipherOperationOnBlock, encryptionOperation: @escaping PGW.CipherOperationOnBlock) throws -> PGW.CipherModeWorker
  var customBlockSize: Swift.Int? { get }
}
@_hasMissingDesignatedInitializers @objc final public class PGWSDK : ObjectiveC.NSObject {
  @objc public static var shared: PGW.PGWSDK {
    @objc get
  }
  @objc final public var pgwSDKParams: PGW.PGWSDKParams! {
    get
  }
  @objc final public class func initialize(params: PGW.PGWSDKParams)
  @objc(paymentOptionWithPaymentOptionRequest:response:failure:) final public func paymentOption(paymentOptionRequest request: PGW.PaymentOptionRequest, _ response: @escaping PGW.APIResponse<PGW.PaymentOptionResponse>, _ failure: @escaping PGW.APIFailure)
  @objc(paymentOptionDetailWithPaymentOptionDetailRequest:response:failure:) final public func paymentOptionDetail(paymentOptionDetailRequest request: PGW.PaymentOptionDetailRequest, _ response: @escaping PGW.APIResponse<PGW.PaymentOptionDetailResponse>, _ failure: @escaping PGW.APIFailure)
  @objc(proceedTransactionWithTransactionResultRequest:response:failure:) final public func proceedTransaction(transactionResultRequest request: PGW.TransactionResultRequest, _ response: @escaping PGW.APIResponse<PGW.TransactionResultResponse>, _ failure: @escaping PGW.APIFailure)
  @objc(cardTokenInfoWithCardTokenInfoRequest:response:failure:) final public func cardTokenInfo(cardTokenInfoRequest request: PGW.CardTokenInfoRequest, _ response: @escaping PGW.APIResponse<PGW.CardTokenInfoResponse>, _ failure: @escaping PGW.APIFailure)
  @objc(exchangeRateWithExchangeRateRequest:response:failure:) final public func exchangeRate(exchangeRateRequest request: PGW.ExchangeRateRequest, _ response: @escaping PGW.APIResponse<PGW.ExchangeRateResponse>, _ failure: @escaping PGW.APIFailure)
  @objc(userPreferenceWithUserPreferenceRequest:response:failure:) final public func userPreference(userPreferenceRequest request: PGW.UserPreferenceRequest, _ response: @escaping PGW.APIResponse<PGW.UserPreferenceResponse>, _ failure: @escaping PGW.APIFailure)
  @objc(transactionStatusWithTransactionStatusRequest:response:failure:) final public func transactionStatus(transactionStatusRequest request: PGW.TransactionStatusRequest, _ response: @escaping PGW.APIResponse<PGW.TransactionStatusResponse>, _ failure: @escaping PGW.APIFailure)
  @objc(systemInitializationWithSystemInitializationRequest:response:failure:) final public func systemInitialization(systemInitializationRequest request: PGW.SystemInitializationRequest, _ response: @escaping PGW.APIResponse<PGW.SystemInitializationResponse>, _ failure: @escaping PGW.APIFailure)
  @objc(paymentNotificationWithPaymentNotificationRequest:response:failure:) final public func paymentNotification(paymentNotificationRequest request: PGW.PaymentNotificationRequest, _ response: @escaping PGW.APIResponse<PGW.PaymentNotificationResponse>, _ failure: @escaping PGW.APIFailure)
  @objc(cancelTransactionWithCancelTransactionRequest:response:failure:) final public func cancelTransaction(cancelTransactionRequest request: PGW.CancelTransactionRequest, _ response: @escaping PGW.APIResponse<PGW.CancelTransactionResponse>, _ failure: @escaping PGW.APIFailure)
  @objc override dynamic public init()
  @objc deinit
}
final public class ChaCha20 {
  public enum Error : Swift.Error {
    case invalidKeyOrInitializationVector
    case notSupported
    public static func == (a: PGW.ChaCha20.Error, b: PGW.ChaCha20.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>, iv nonce: Swift.Array<Swift.UInt8>) throws
  @objc deinit
}
extension ChaCha20 : PGW.Cipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension ChaCha20 {
  public struct ChaChaEncryptor : PGW.Cryptor, PGW.Updatable {
    public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
    public func seek(to: Swift.Int) throws
  }
}
extension ChaCha20 {
  public struct ChaChaDecryptor : PGW.Cryptor, PGW.Updatable {
    public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = true) throws -> Swift.Array<Swift.UInt8>
    public func seek(to: Swift.Int) throws
  }
}
extension ChaCha20 : PGW.Cryptors {
  final public func makeEncryptor() -> PGW.Cryptor & PGW.Updatable
  final public func makeDecryptor() -> PGW.Cryptor & PGW.Updatable
}
public enum Bit : Swift.Int {
  case zero
  case one
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension Bit {
  @inlinable internal func inverted() -> PGW.Bit {
    self == .zero ? .one : .zero
  }
}
@_inheritsConvenienceInitializers final public class CBCMAC : PGW.CMAC {
  override final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  override public init(key: Swift.Array<Swift.UInt8>) throws
  @objc deinit
}
@_inheritsConvenienceInitializers @objc public class BaseCardPaymentBuilder : PGW.BasePaymentBuilder {
  @objc override public init(paymentCode: PGW.PaymentCode)
  @objc deinit
}
@objc public class BasePaymentBuilder : PGW.BaseModel {
  @objc public init(paymentCode: PGW.PaymentCode)
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc final public class CardTokenPaymentBuilder : PGW.BaseCardPaymentBuilder {
  @objc(initWithPaymentCode:token:) public init(paymentCode: PGW.PaymentCode, _ token: Swift.String)
  @objc(initWithChannelCode:token:) public init(channelCode: Swift.String, _ token: Swift.String)
  @objc final public func expiryMonth(_ month: Swift.Int) -> PGW.CardTokenPaymentBuilder
  @objc final public func expiryYear(_ year: Swift.Int) -> PGW.CardTokenPaymentBuilder
  @objc final public func securityCode(_ securityCode: Swift.String) -> PGW.CardTokenPaymentBuilder
  @objc final public func pin(_ pin: Swift.String) -> PGW.CardTokenPaymentBuilder
  @objc final public func installmentInterestType(_ installmentInterestType: Swift.String) -> PGW.CardTokenPaymentBuilder
  @objc final public func installmentPeriod(_ installmentPeriod: Swift.Int) -> PGW.CardTokenPaymentBuilder
  @objc final public func fxRateId(_ fxRateId: Swift.String) -> PGW.CardTokenPaymentBuilder
  @objc final public func name(_ name: Swift.String) -> PGW.CardTokenPaymentBuilder
  @objc final public func email(_ email: Swift.String) -> PGW.CardTokenPaymentBuilder
  @objc final public func mobileNo(_ mobileNo: Swift.String) -> PGW.CardTokenPaymentBuilder
  @objc final public func userAddress(_ userAddress: PGW.UserAddress) -> PGW.CardTokenPaymentBuilder
  @objc final public func build() -> PGW.PaymentRequest
  @objc deinit
}
@_inheritsConvenienceInitializers @objc final public class InternetBankingBuilder : PGW.BaseAlternativePaymentMethodBuilder {
  @objc override public init(paymentCode: PGW.PaymentCode)
  @objc(initWithChannelCode:agentCode:agentChannelCode:) override public init(channelCode: Swift.String, _ agentCode: Swift.String, _ agentChannelCode: Swift.String)
  @objc final public func fxRateId(_ fxRateId: Swift.String) -> PGW.InternetBankingBuilder
  @objc final public func name(_ name: Swift.String) -> PGW.InternetBankingBuilder
  @objc final public func email(_ email: Swift.String) -> PGW.InternetBankingBuilder
  @objc final public func mobileNo(_ mobileNo: Swift.String) -> PGW.InternetBankingBuilder
  @objc final public func userAddress(_ userAddress: PGW.UserAddress) -> PGW.InternetBankingBuilder
  @objc deinit
}
@_inheritsConvenienceInitializers @objc final public class DigitalPaymentBuilder : PGW.BasePaymentBuilder {
  @objc override public init(paymentCode: PGW.PaymentCode)
  @objc public init(channelCode: Swift.String)
  @objc final public func accountNo(_ accountNo: Swift.String) -> PGW.DigitalPaymentBuilder
  @objc final public func token(_ token: Swift.String) -> PGW.DigitalPaymentBuilder
  @objc final public func fxRateId(_ fxRateId: Swift.String) -> PGW.DigitalPaymentBuilder
  @objc final public func name(_ name: Swift.String) -> PGW.DigitalPaymentBuilder
  @objc final public func email(_ email: Swift.String) -> PGW.DigitalPaymentBuilder
  @objc final public func mobileNo(_ mobileNo: Swift.String) -> PGW.DigitalPaymentBuilder
  @objc final public func userAddress(_ userAddress: PGW.UserAddress) -> PGW.DigitalPaymentBuilder
  @objc final public func build() -> PGW.PaymentRequest
  @objc deinit
}
@usableFromInline
internal struct BatchedCollectionIndex<Base> where Base : Swift.Collection {
}
extension BatchedCollectionIndex : Swift.Comparable {
  @usableFromInline
  internal static func == <Base>(lhs: PGW.BatchedCollectionIndex<Base>, rhs: PGW.BatchedCollectionIndex<Base>) -> Swift.Bool where Base : Swift.Collection
  @usableFromInline
  internal static func < <Base>(lhs: PGW.BatchedCollectionIndex<Base>, rhs: PGW.BatchedCollectionIndex<Base>) -> Swift.Bool where Base : Swift.Collection
}
@usableFromInline
internal struct BatchedCollection<Base> : Swift.Collection where Base : Swift.Collection {
  @usableFromInline
  internal init(base: Base, size: Swift.Int)
  @usableFromInline
  internal typealias Index = PGW.BatchedCollectionIndex<Base>
  @usableFromInline
  internal var startIndex: PGW.BatchedCollection<Base>.Index {
    get
  }
  @usableFromInline
  internal var endIndex: PGW.BatchedCollection<Base>.Index {
    get
  }
  @usableFromInline
  internal func index(after idx: PGW.BatchedCollection<Base>.Index) -> PGW.BatchedCollection<Base>.Index
  @usableFromInline
  internal subscript(idx: PGW.BatchedCollection<Base>.Index) -> Base.SubSequence {
    get
  }
  @usableFromInline
  internal typealias Element = Base.SubSequence
  @usableFromInline
  internal typealias Indices = Swift.DefaultIndices<PGW.BatchedCollection<Base>>
  @usableFromInline
  internal typealias Iterator = Swift.IndexingIterator<PGW.BatchedCollection<Base>>
  @usableFromInline
  internal typealias SubSequence = Swift.Slice<PGW.BatchedCollection<Base>>
}
extension Collection {
  @inlinable internal func batched(by size: Swift.Int) -> PGW.BatchedCollection<Self> {
    BatchedCollection(base: self, size: size)
  }
}
@objc final public class TransactionResultRequestBuilder : PGW.BaseModel {
  @objc public init(paymentToken: Swift.String)
  @objc final public func clientId(_ clientId: Swift.String) -> PGW.TransactionResultRequestBuilder
  @objc final public func locale(_ locale: Swift.String) -> PGW.TransactionResultRequestBuilder
  @objc(withPaymentRequest:) final public func with(_ paymentRequest: PGW.PaymentRequest) -> PGW.TransactionResultRequestBuilder
  @objc final public func build() -> PGW.TransactionResultRequest
  @objc override dynamic public init()
  @objc deinit
}
@objc final public class PGWSDKParamsBuilder : PGW.BaseModel {
  @objc public init(apiEnvironment: PGW.APIEnvironment)
  @objc final public func clientId(_ clientId: Swift.String) -> PGW.PGWSDKParamsBuilder
  @objc final public func locale(_ locale: Swift.String) -> PGW.PGWSDKParamsBuilder
  @objc final public func log(_ enable: Swift.Bool) -> PGW.PGWSDKParamsBuilder
  @objc final public func build() -> PGW.PGWSDKParams
  @objc override dynamic public init()
  @objc deinit
}
final public class SHA3 {
  final public let blockSize: Swift.Int
  final public let digestLength: Swift.Int
  final public let markByte: Swift.UInt8
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var accumulatedHash: Swift.Array<Swift.UInt64>
  public enum Variant {
    case sha224, sha256, sha384, sha512, keccak224, keccak256, keccak384, keccak512
    public var outputLength: Swift.Int {
      get
    }
    public static func == (a: PGW.SHA3.Variant, b: PGW.SHA3.Variant) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(variant: PGW.SHA3.Variant)
  @inlinable final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8> {
    do {
      return try update(withBytes: bytes.slice, isLast: true)
    } catch {
      return []
    }
  }
  @usableFromInline
  final internal func process(block chunk: Swift.ArraySlice<Swift.UInt64>, currentHash hh: inout Swift.Array<Swift.UInt64>)
  @objc deinit
}
extension SHA3 : PGW.Updatable {
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    if isLast {
      // Add padding
      let markByteIndex = self.accumulated.count

      // We need to always pad the input. Even if the input is a multiple of blockSize.
      let r = self.blockSize * 8
      let q = (r / 8) - (accumulated.count % (r / 8))
      self.accumulated += Array<UInt8>(repeating: 0, count: q)

      self.accumulated[markByteIndex] |= self.markByte
      self.accumulated[self.accumulated.count - 1] |= 0x80
    }

    var processedBytes = 0
    for chunk in self.accumulated.batched(by: self.blockSize) {
      if isLast || (self.accumulated.count - processedBytes) >= self.blockSize {
        self.process(block: chunk.toUInt64Array().slice, currentHash: &self.accumulatedHash)
        processedBytes += chunk.count
      }
    }
    self.accumulated.removeFirst(processedBytes)

    // TODO: verify performance, reduce vs for..in
    let result = self.accumulatedHash.reduce(into: Array<UInt8>()) { (result, value) in
      result += value.bigEndian.bytes()
    }

    // reset hash value for instance
    if isLast {
      self.accumulatedHash = Array<UInt64>(repeating: 0, count: self.digestLength)
    }

    return Array(result[0..<self.digestLength])
  }
}
@_inheritsConvenienceInitializers @objc final public class CardPaymentBuilder : PGW.BaseCardPaymentBuilder {
  @objc override public init(paymentCode: PGW.PaymentCode)
  @objc(initWithPaymentCode:cardNo:) public init(paymentCode: PGW.PaymentCode, _ cardNo: Swift.String)
  @objc public init(channelCode: Swift.String)
  @objc(initWithChannelCode:cardNo:) public init(channelCode: Swift.String, _ cardNo: Swift.String)
  @objc final public func expiryMonth(_ month: Swift.Int) -> PGW.CardPaymentBuilder
  @objc final public func expiryYear(_ year: Swift.Int) -> PGW.CardPaymentBuilder
  @objc final public func securityCode(_ securityCode: Swift.String) -> PGW.CardPaymentBuilder
  @objc final public func pin(_ pin: Swift.String) -> PGW.CardPaymentBuilder
  @objc final public func bank(_ bank: Swift.String) -> PGW.CardPaymentBuilder
  @objc final public func country(_ country: Swift.String) -> PGW.CardPaymentBuilder
  @objc final public func tokenize(_ tokenize: Swift.Bool) -> PGW.CardPaymentBuilder
  @objc final public func installmentInterestType(_ installmentInterestType: Swift.String) -> PGW.CardPaymentBuilder
  @objc final public func installmentPeriod(_ installmentPeriod: Swift.Int) -> PGW.CardPaymentBuilder
  @objc final public func fxRateId(_ fxRateId: Swift.String) -> PGW.CardPaymentBuilder
  @objc final public func name(_ name: Swift.String) -> PGW.CardPaymentBuilder
  @objc final public func email(_ email: Swift.String) -> PGW.CardPaymentBuilder
  @objc final public func mobileNo(_ mobileNo: Swift.String) -> PGW.CardPaymentBuilder
  @objc final public func userAddress(_ userAddress: PGW.UserAddress) -> PGW.CardPaymentBuilder
  @objc final public func build() -> PGW.PaymentRequest
  @objc deinit
}
@_inheritsConvenienceInitializers @objc final public class UniversalPaymentBuilder : PGW.BasePaymentBuilder {
  @objc override public init(paymentCode: PGW.PaymentCode)
  @objc(initWithChannelCode:agentCode:agentChannelCode:) public init(channelCode: Swift.String, _ agentCode: Swift.String, _ agentChannelCode: Swift.String)
  @objc final public func accountNo(_ accountNo: Swift.String) -> PGW.UniversalPaymentBuilder
  @objc final public func cardNo(_ cardNo: Swift.String) -> PGW.UniversalPaymentBuilder
  @objc final public func expiryMonth(_ month: Swift.Int) -> PGW.UniversalPaymentBuilder
  @objc final public func expiryYear(_ year: Swift.Int) -> PGW.UniversalPaymentBuilder
  @objc final public func securityCode(_ securityCode: Swift.String) -> PGW.UniversalPaymentBuilder
  @objc final public func pin(_ pin: Swift.String) -> PGW.UniversalPaymentBuilder
  @objc final public func bank(_ bank: Swift.String) -> PGW.UniversalPaymentBuilder
  @objc final public func country(_ country: Swift.String) -> PGW.UniversalPaymentBuilder
  @objc final public func tokenize(_ tokenize: Swift.Bool) -> PGW.UniversalPaymentBuilder
  @objc final public func installmentInterestType(_ installmentInterestType: Swift.String) -> PGW.UniversalPaymentBuilder
  @objc final public func installmentPeriod(_ installmentPeriod: Swift.Int) -> PGW.UniversalPaymentBuilder
  @objc final public func token(_ token: Swift.String) -> PGW.UniversalPaymentBuilder
  @objc final public func qrType(_ type: Swift.String) -> PGW.UniversalPaymentBuilder
  @objc final public func fxRateId(_ fxRateId: Swift.String) -> PGW.UniversalPaymentBuilder
  @objc final public func name(_ name: Swift.String) -> PGW.UniversalPaymentBuilder
  @objc final public func email(_ email: Swift.String) -> PGW.UniversalPaymentBuilder
  @objc final public func mobileNo(_ mobileNo: Swift.String) -> PGW.UniversalPaymentBuilder
  @objc final public func userAddress(_ userAddress: PGW.UserAddress) -> PGW.UniversalPaymentBuilder
  @objc final public func build() -> PGW.PaymentRequest
  @objc deinit
}
extension FixedWidthInteger {
  @inlinable internal func bytes(totalBytes: Swift.Int = MemoryLayout<Self>.size) -> Swift.Array<Swift.UInt8> {
    arrayOfBytes(value: self.littleEndian, length: totalBytes)
    // TODO: adjust bytes order
    // var value = self.littleEndian
    // return withUnsafeBytes(of: &value, Array.init).reversed()
  }
}
@_inheritsConvenienceInitializers @objc final public class MerchantAdditionalInfo : PGW.BaseMerchantInfo {
  @objc override dynamic public init()
  @objc deinit
}
@usableFromInline
final internal class StreamEncryptor : PGW.Cryptor, PGW.Updatable {
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal var worker: PGW.CipherModeWorker
  @usableFromInline
  final internal let padding: PGW.Padding
  @usableFromInline
  final internal var lastBlockRemainder: Swift.Int
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: PGW.Padding, _ worker: PGW.CipherModeWorker) throws
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8> {
    var accumulated = Array(bytes)
    if isLast {
      // CTR doesn't need padding. Really. Add padding to the last block if really want. but... don't.
      accumulated = self.padding.add(to: accumulated, blockSize: self.blockSize - self.lastBlockRemainder)
    }

    var encrypted = Array<UInt8>(reserveCapacity: bytes.count)
    for chunk in accumulated.batched(by: self.blockSize) {
      encrypted += self.worker.encrypt(block: chunk)
    }

    // omit unecessary calculation if not needed
    if self.padding != .noPadding {
      self.lastBlockRemainder = encrypted.count.quotientAndRemainder(dividingBy: self.blockSize).remainder
    }

    if var finalizingWorker = worker as? FinalizingEncryptModeWorker, isLast == true {
      encrypted = Array(try finalizingWorker.finalize(encrypt: encrypted.slice))
    }

    return encrypted
  }
  @usableFromInline
  final internal func seek(to: Swift.Int) throws
  @objc @usableFromInline
  deinit
}
@_inheritsConvenienceInitializers @objc final public class AmountValidation : PGW.BaseModel {
  @objc final public var min: Swift.Double {
    get
  }
  @objc final public var max: Swift.Double {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
@available(*, renamed: "Digest")
public typealias Hash = PGW.Digest
public struct Digest {
  public static func md5(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha1(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha224(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha256(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha384(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha512(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha2(_ bytes: Swift.Array<Swift.UInt8>, variant: PGW.SHA2.Variant) -> Swift.Array<Swift.UInt8>
  public static func sha3(_ bytes: Swift.Array<Swift.UInt8>, variant: PGW.SHA3.Variant) -> Swift.Array<Swift.UInt8>
}
final public class Checksum {
  @usableFromInline
  internal static let table32: [Swift.UInt32]
  @usableFromInline
  internal static let table32c: [Swift.UInt32]
  @usableFromInline
  internal static let table16: [Swift.UInt16]
  @usableFromInline
  internal init()
  @inlinable final internal func crc32(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    var crc: UInt32 = seed != nil ? seed! : 0xFFFF_FFFF
    for chunk in message.batched(by: 256) {
      for b in chunk {
        let idx = Int((crc ^ UInt32(reflect ? b : reversed(b))) & 0xFF)
        crc = (crc >> 8) ^ Checksum.table32[idx]
      }
    }
    return (reflect ? crc : reversed(crc)) ^ 0xFFFF_FFFF
  }
  @inlinable final internal func crc32c(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    var crc: UInt32 = seed != nil ? seed! : 0xFFFF_FFFF
    for chunk in message.batched(by: 256) {
      for b in chunk {
        let idx = Int((crc ^ UInt32(reflect ? b : reversed(b))) & 0xFF)
        crc = (crc >> 8) ^ Checksum.table32c[idx]
      }
    }
    return (reflect ? crc : reversed(crc)) ^ 0xFFFF_FFFF
  }
  @inlinable final internal func crc16(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt16? = nil) -> Swift.UInt16 {
    var crc: UInt16 = seed != nil ? seed! : 0x0000
    for chunk in message.batched(by: 256) {
      for b in chunk {
        crc = (crc >> 8) ^ Checksum.table16[Int((crc ^ UInt16(b)) & 0xFF)]
      }
    }
    return crc
  }
  @objc deinit
}
extension Checksum {
  @inlinable public static func crc32(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    Checksum().crc32(message, seed: seed, reflect: reflect)
  }
  @inlinable public static func crc32c(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    Checksum().crc32c(message, seed: seed, reflect: reflect)
  }
  @inlinable public static func crc16(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt16? = nil) -> Swift.UInt16 {
    Checksum().crc16(message, seed: seed)
  }
}
@_inheritsConvenienceInitializers @objc public class BaseTransactionInfo : PGW.BaseModel {
  @objc public var amount: Swift.String! {
    get
  }
  @objc public var currencyCode: Swift.String! {
    get
  }
  @objc public var invoiceNo: Swift.String! {
    get
  }
  @objc public var productDescription: Swift.String! {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc final public class TransactionAdditionalInfo : PGW.BaseTransactionInfo {
  @objc final public var dateTime: Swift.String! {
    get
  }
  @objc final public var agentCode: Swift.String! {
    get
  }
  @objc final public var channelCode: Swift.String! {
    get
  }
  @objc final public var data: Swift.String! {
    get
  }
  @objc final public var interestType: Swift.String! {
    get
  }
  @objc final public var interestRate: Swift.Double {
    get
  }
  @objc final public var monthlyAmount: Swift.Double {
    get
  }
  @objc final public var installmentPeriod: Swift.Int {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
public protocol Authenticator {
  func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
@_inheritsConvenienceInitializers @objc final public class QRPaymentBuilder : PGW.BasePaymentBuilder {
  @objc override public init(paymentCode: PGW.PaymentCode)
  @objc public init(channelCode: Swift.String)
  @objc final public func type(_ type: Swift.String) -> PGW.QRPaymentBuilder
  @objc final public func fxRateId(_ fxRateId: Swift.String) -> PGW.QRPaymentBuilder
  @objc final public func name(_ name: Swift.String) -> PGW.QRPaymentBuilder
  @objc final public func email(_ email: Swift.String) -> PGW.QRPaymentBuilder
  @objc final public func mobileNo(_ mobileNo: Swift.String) -> PGW.QRPaymentBuilder
  @objc final public func userAddress(_ userAddress: PGW.UserAddress) -> PGW.QRPaymentBuilder
  @objc final public func build() -> PGW.PaymentRequest
  @objc deinit
}
public struct CCM {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    case invalidParameter
    case fail
    public static func == (a: PGW.CCM.Error, b: PGW.CCM.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: PGW.BlockModeOption
  public let customBlockSize: Swift.Int?
  public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(iv: Swift.Array<Swift.UInt8>, tagLength: Swift.Int, messageLength: Swift.Int, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil)
  public init(iv: Swift.Array<Swift.UInt8>, tagLength: Swift.Int, messageLength: Swift.Int, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping PGW.CipherOperationOnBlock, encryptionOperation: @escaping PGW.CipherOperationOnBlock) throws -> PGW.CipherModeWorker
}
final public class Scrypt {
  public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, dkLen: Swift.Int, N: Swift.Int, r: Swift.Int, p: Swift.Int) throws
  final public func calculate() throws -> [Swift.UInt8]
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class BaseMerchantInfo : PGW.BaseModel {
  @objc public var id: Swift.String! {
    get
  }
  @objc public var name: Swift.String! {
    get
  }
  @objc public var address: Swift.String! {
    get
  }
  @objc public var email: Swift.String! {
    get
  }
  @objc public var logoUrl: Swift.String! {
    get
  }
  @objc public var bannerUrl: Swift.String! {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc final public class WebPaymentBuilder : PGW.BaseAlternativePaymentMethodBuilder {
  @objc override public init(paymentCode: PGW.PaymentCode)
  @objc(initWithChannelCode:agentCode:agentChannelCode:) override public init(channelCode: Swift.String, _ agentCode: Swift.String, _ agentChannelCode: Swift.String)
  @objc final public func fxRateId(_ fxRateId: Swift.String) -> PGW.WebPaymentBuilder
  @objc final public func name(_ name: Swift.String) -> PGW.WebPaymentBuilder
  @objc final public func email(_ email: Swift.String) -> PGW.WebPaymentBuilder
  @objc final public func mobileNo(_ mobileNo: Swift.String) -> PGW.WebPaymentBuilder
  @objc final public func userAddress(_ userAddress: PGW.UserAddress) -> PGW.WebPaymentBuilder
  @objc deinit
}
@_inheritsConvenienceInitializers @objc final public class SelfServiceMachineBuilder : PGW.BaseAlternativePaymentMethodBuilder {
  @objc override public init(paymentCode: PGW.PaymentCode)
  @objc(initWithChannelCode:agentCode:agentChannelCode:) override public init(channelCode: Swift.String, _ agentCode: Swift.String, _ agentChannelCode: Swift.String)
  @objc final public func fxRateId(_ fxRateId: Swift.String) -> PGW.SelfServiceMachineBuilder
  @objc final public func name(_ name: Swift.String) -> PGW.SelfServiceMachineBuilder
  @objc final public func email(_ email: Swift.String) -> PGW.SelfServiceMachineBuilder
  @objc final public func mobileNo(_ mobileNo: Swift.String) -> PGW.SelfServiceMachineBuilder
  @objc final public func userAddress(_ userAddress: PGW.UserAddress) -> PGW.SelfServiceMachineBuilder
  @objc deinit
}
@_inheritsConvenienceInitializers @objc final public class PayAtCounterBuilder : PGW.BaseAlternativePaymentMethodBuilder {
  @objc override public init(paymentCode: PGW.PaymentCode)
  @objc(initWithChannelCode:agentCode:agentChannelCode:) override public init(channelCode: Swift.String, _ agentCode: Swift.String, _ agentChannelCode: Swift.String)
  @objc final public func fxRateId(_ fxRateId: Swift.String) -> PGW.PayAtCounterBuilder
  @objc final public func name(_ name: Swift.String) -> PGW.PayAtCounterBuilder
  @objc final public func email(_ email: Swift.String) -> PGW.PayAtCounterBuilder
  @objc final public func mobileNo(_ mobileNo: Swift.String) -> PGW.PayAtCounterBuilder
  @objc final public func userAddress(_ userAddress: PGW.UserAddress) -> PGW.PayAtCounterBuilder
  @objc deinit
}
@_inheritsConvenienceInitializers @objc public class BaseAlternativePaymentMethodBuilder : PGW.BasePaymentBuilder {
  @objc override public init(paymentCode: PGW.PaymentCode)
  @objc(initWithChannelCode:agentCode:agentChannelCode:) public init(channelCode: Swift.String, _ agentCode: Swift.String, _ agentChannelCode: Swift.String)
  @objc public func build() -> PGW.PaymentRequest
  @objc deinit
}
public enum CipherError : Swift.Error {
  case encrypt
  case decrypt
  public static func == (a: PGW.CipherError, b: PGW.CipherError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol Cipher : AnyObject {
  var keySize: Swift.Int { get }
  func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func encrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func decrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension Cipher {
  public func encrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public func decrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
final public class AES {
  public enum Error : Swift.Error {
    case invalidKeySize
    case dataPaddingRequired
    case invalidData
    public static func == (a: PGW.AES.Error, b: PGW.AES.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Variant : Swift.Int {
    case aes128, aes192, aes256
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @usableFromInline
  final internal let variantNr: Swift.Int
  @usableFromInline
  final internal let variantNb: Swift.Int
  @usableFromInline
  final internal let variantNk: Swift.Int
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  final public let variant: PGW.AES.Variant
  @usableFromInline
  final internal let blockMode: PGW.BlockMode
  @usableFromInline
  final internal let padding: PGW.Padding
  @usableFromInline
  final internal var expandedKey: Swift.Array<Swift.Array<Swift.UInt32>> {
    get
    set
  }
  @usableFromInline
  final internal var expandedKeyInv: Swift.Array<Swift.Array<Swift.UInt32>> {
    get
    set
  }
  @usableFromInline
  internal static let T0: [Swift.UInt32]
  @usableFromInline
  internal static let T0_INV: [Swift.UInt32]
  @usableFromInline
  internal static let T1: [Swift.UInt32]
  @usableFromInline
  internal static let T1_INV: [Swift.UInt32]
  @usableFromInline
  internal static let T2: [Swift.UInt32]
  @usableFromInline
  internal static let T2_INV: [Swift.UInt32]
  @usableFromInline
  internal static let T3: [Swift.UInt32]
  @usableFromInline
  internal static let T3_INV: [Swift.UInt32]
  @usableFromInline
  internal static let U1: [Swift.UInt32]
  @usableFromInline
  internal static let U2: [Swift.UInt32]
  @usableFromInline
  internal static let U3: [Swift.UInt32]
  @usableFromInline
  internal static let U4: [Swift.UInt32]
  public init(key: Swift.Array<Swift.UInt8>, blockMode: PGW.BlockMode, padding: PGW.Padding = .pkcs7) throws
  @inlinable final internal func encrypt(block: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>? {
    if self.blockMode.options.contains(.paddingRequired) && block.count != AES.blockSize {
      return Array(block)
    }

    let rounds = self.variantNr
    let rk = self.expandedKey

    let b00 = UInt32(block[block.startIndex.advanced(by: 0)])
    let b01 = UInt32(block[block.startIndex.advanced(by: 1)]) << 8
    let b02 = UInt32(block[block.startIndex.advanced(by: 2)]) << 16
    let b03 = UInt32(block[block.startIndex.advanced(by: 3)]) << 24
    var b0 = b00 | b01 | b02 | b03

    let b10 = UInt32(block[block.startIndex.advanced(by: 4)])
    let b11 = UInt32(block[block.startIndex.advanced(by: 5)]) << 8
    let b12 = UInt32(block[block.startIndex.advanced(by: 6)]) << 16
    let b13 = UInt32(block[block.startIndex.advanced(by: 7)]) << 24
    var b1 = b10 | b11 | b12 | b13

    let b20 = UInt32(block[block.startIndex.advanced(by: 8)])
    let b21 = UInt32(block[block.startIndex.advanced(by: 9)]) << 8
    let b22 = UInt32(block[block.startIndex.advanced(by: 10)]) << 16
    let b23 = UInt32(block[block.startIndex.advanced(by: 11)]) << 24
    var b2 = b20 | b21 | b22 | b23

    let b30 = UInt32(block[block.startIndex.advanced(by: 12)])
    let b31 = UInt32(block[block.startIndex.advanced(by: 13)]) << 8
    let b32 = UInt32(block[block.startIndex.advanced(by: 14)]) << 16
    let b33 = UInt32(block[block.startIndex.advanced(by: 15)]) << 24
    var b3 = b30 | b31 | b32 | b33

    let tLength = 4
    let t = UnsafeMutablePointer<UInt32>.allocate(capacity: tLength)
    t.initialize(repeating: 0, count: tLength)
    defer {
      t.deinitialize(count: tLength)
      t.deallocate()
    }

    for r in 0..<rounds - 1 {
      t[0] = b0 ^ rk[r][0]
      t[1] = b1 ^ rk[r][1]
      t[2] = b2 ^ rk[r][2]
      t[3] = b3 ^ rk[r][3]

      let lb00 = AES.T0[Int(t[0] & 0xff)]
      let lb01 = AES.T1[Int((t[1] >> 8) & 0xff)]
      let lb02 = AES.T2[Int((t[2] >> 16) & 0xff)]
      let lb03 = AES.T3[Int(t[3] >> 24)]
      b0 = lb00 ^ lb01 ^ lb02 ^ lb03

      let lb10 = AES.T0[Int(t[1] & 0xff)]
      let lb11 = AES.T1[Int((t[2] >> 8) & 0xff)]
      let lb12 = AES.T2[Int((t[3] >> 16) & 0xff)]
      let lb13 = AES.T3[Int(t[0] >> 24)]
      b1 = lb10 ^ lb11 ^ lb12 ^ lb13

      let lb20 = AES.T0[Int(t[2] & 0xff)]
      let lb21 = AES.T1[Int((t[3] >> 8) & 0xff)]
      let lb22 = AES.T2[Int((t[0] >> 16) & 0xff)]
      let lb23 = AES.T3[Int(t[1] >> 24)]
      b2 = lb20 ^ lb21 ^ lb22 ^ lb23

      let lb30 = AES.T0[Int(t[3] & 0xff)]
      let lb31 = AES.T1[Int((t[0] >> 8) & 0xff)]
      let lb32 = AES.T2[Int((t[1] >> 16) & 0xff)]
      let lb33 = AES.T3[Int(t[2] >> 24)]
      b3 = lb30 ^ lb31 ^ lb32 ^ lb33
    }

    // last round
    let r = rounds - 1

    t[0] = b0 ^ rk[r][0]
    t[1] = b1 ^ rk[r][1]
    t[2] = b2 ^ rk[r][2]
    t[3] = b3 ^ rk[r][3]

    // rounds
    b0 = F1(t[0], t[1], t[2], t[3]) ^ rk[rounds][0]
    b1 = F1(t[1], t[2], t[3], t[0]) ^ rk[rounds][1]
    b2 = F1(t[2], t[3], t[0], t[1]) ^ rk[rounds][2]
    b3 = F1(t[3], t[0], t[1], t[2]) ^ rk[rounds][3]

    let encrypted: Array<UInt8> = [
      UInt8(b0 & 0xff), UInt8((b0 >> 8) & 0xff), UInt8((b0 >> 16) & 0xff), UInt8((b0 >> 24) & 0xff),
      UInt8(b1 & 0xff), UInt8((b1 >> 8) & 0xff), UInt8((b1 >> 16) & 0xff), UInt8((b1 >> 24) & 0xff),
      UInt8(b2 & 0xff), UInt8((b2 >> 8) & 0xff), UInt8((b2 >> 16) & 0xff), UInt8((b2 >> 24) & 0xff),
      UInt8(b3 & 0xff), UInt8((b3 >> 8) & 0xff), UInt8((b3 >> 16) & 0xff), UInt8((b3 >> 24) & 0xff)
    ]
    return encrypted
  }
  @usableFromInline
  final internal func decrypt(block: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>?
  @objc deinit
}
extension AES {
  @usableFromInline
  @inline(__always) final internal func F1(_ x0: Swift.UInt32, _ x1: Swift.UInt32, _ x2: Swift.UInt32, _ x3: Swift.UInt32) -> Swift.UInt32
}
extension AES : PGW.Cipher {
  @inlinable final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    let blockSize = self.blockMode.customBlockSize ?? AES.blockSize
    let chunks = bytes.batched(by: blockSize)

    var oneTimeCryptor = try makeEncryptor()
    var out = Array<UInt8>(reserveCapacity: bytes.count)
    for chunk in chunks {
      out += try oneTimeCryptor.update(withBytes: chunk, isLast: false)
    }
    // Padding may be added at the very end
    out += try oneTimeCryptor.finish()

    if self.blockMode.options.contains(.paddingRequired) && (out.count % AES.blockSize != 0) {
      throw Error.dataPaddingRequired
    }

    return out
  }
  @inlinable final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    if self.blockMode.options.contains(.paddingRequired) && (bytes.count % AES.blockSize != 0) {
      throw Error.dataPaddingRequired
    }

    var oneTimeCryptor = try makeDecryptor()
    let chunks = bytes.batched(by: AES.blockSize)
    if chunks.isEmpty {
      throw Error.invalidData
    }

    var out = Array<UInt8>(reserveCapacity: bytes.count)

    var lastIdx = chunks.startIndex
    chunks.indices.formIndex(&lastIdx, offsetBy: chunks.count - 1)

    // To properly remove padding, `isLast` has to be known when called with the last chunk of ciphertext
    // Last chunk of ciphertext may contains padded data so next call to update(..) won't be able to remove it
    for idx in chunks.indices {
      out += try oneTimeCryptor.update(withBytes: chunks[idx], isLast: idx == lastIdx)
    }
    return out
  }
}
extension PGW.CFB.Error : Swift.Equatable {}
extension PGW.CFB.Error : Swift.Hashable {}
extension PGW.CFB.SegmentSize : Swift.Equatable {}
extension PGW.CFB.SegmentSize : Swift.Hashable {}
extension PGW.CFB.SegmentSize : Swift.RawRepresentable {}
extension PGW.SecurePayAPIEnvironment : Swift.Equatable {}
extension PGW.SecurePayAPIEnvironment : Swift.Hashable {}
extension PGW.SecurePayAPIEnvironment : Swift.RawRepresentable {}
extension PGW.CTR : PGW.BlockMode {}
extension PGW.CTR.Error : Swift.Equatable {}
extension PGW.CTR.Error : Swift.Hashable {}
extension PGW.CMAC.Error : Swift.Equatable {}
extension PGW.CMAC.Error : Swift.Hashable {}
extension PGW.OFB.Error : Swift.Equatable {}
extension PGW.OFB.Error : Swift.Hashable {}
extension PGW.OCB.Mode : Swift.Equatable {}
extension PGW.OCB.Mode : Swift.Hashable {}
extension PGW.OCB.Error : Swift.Equatable {}
extension PGW.OCB.Error : Swift.Hashable {}
extension PGW.Blowfish.Error : Swift.Equatable {}
extension PGW.Blowfish.Error : Swift.Hashable {}
extension PGW.PCBC.Error : Swift.Equatable {}
extension PGW.PCBC.Error : Swift.Hashable {}
extension PGW.PKCS5.PBKDF1.Error : Swift.Equatable {}
extension PGW.PKCS5.PBKDF1.Error : Swift.Hashable {}
extension PGW.PKCS5.PBKDF1.Variant : Swift.Equatable {}
extension PGW.PKCS5.PBKDF1.Variant : Swift.Hashable {}
extension PGW.GCM.Mode : Swift.Equatable {}
extension PGW.GCM.Mode : Swift.Hashable {}
extension PGW.GCM.Error : Swift.Equatable {}
extension PGW.GCM.Error : Swift.Hashable {}
extension PGW.HMAC.Error : Swift.Equatable {}
extension PGW.HMAC.Error : Swift.Hashable {}
extension PGW.HMAC.Variant : Swift.Equatable {}
extension PGW.HMAC.Variant : Swift.Hashable {}
extension PGW.HKDF.Error : Swift.Equatable {}
extension PGW.HKDF.Error : Swift.Hashable {}
extension PGW.Poly1305.Error : Swift.Equatable {}
extension PGW.Poly1305.Error : Swift.Hashable {}
extension PGW.SHA2.Variant : Swift.Equatable {}
extension PGW.SHA2.Variant : Swift.Hashable {}
extension PGW.PKCS5.PBKDF2.Error : Swift.Equatable {}
extension PGW.PKCS5.PBKDF2.Error : Swift.Hashable {}
extension PGW.Padding : Swift.Equatable {}
extension PGW.Padding : Swift.Hashable {}
extension PGW.APIEnvironment : Swift.Equatable {}
extension PGW.APIEnvironment : Swift.Hashable {}
extension PGW.APIEnvironment : Swift.RawRepresentable {}
extension PGW.CBC.Error : Swift.Equatable {}
extension PGW.CBC.Error : Swift.Hashable {}
extension PGW.Rabbit.Error : Swift.Equatable {}
extension PGW.Rabbit.Error : Swift.Hashable {}
extension PGW.ChaCha20.Error : Swift.Equatable {}
extension PGW.ChaCha20.Error : Swift.Hashable {}
extension PGW.Bit : Swift.Equatable {}
extension PGW.Bit : Swift.Hashable {}
extension PGW.Bit : Swift.RawRepresentable {}
extension PGW.SHA3.Variant : Swift.Equatable {}
extension PGW.SHA3.Variant : Swift.Hashable {}
extension PGW.CCM : PGW.BlockMode {}
extension PGW.CCM.Error : Swift.Equatable {}
extension PGW.CCM.Error : Swift.Hashable {}
extension PGW.CipherError : Swift.Equatable {}
extension PGW.CipherError : Swift.Hashable {}
extension PGW.AES.Error : Swift.Equatable {}
extension PGW.AES.Error : Swift.Hashable {}
extension PGW.AES.Variant : Swift.Equatable {}
extension PGW.AES.Variant : Swift.Hashable {}
extension PGW.AES.Variant : Swift.RawRepresentable {}
